import { isTransformationBranch } from "../../nodes/branch.js";
import { throwInternalError, throwParseError } from "../../utils/errors.js";
import { isArray } from "../../utils/objectKinds.js";
import { stringify } from "../../utils/serialize.js";
import { parseDefinition } from "../definition.js";
export const parseMorphTuple = (def, ctx)=>{
    if (typeof def[2] !== "function") {
        return throwParseError(writeMalformedMorphExpressionMessage(def[2]));
    }
    const node = parseDefinition(def[0], ctx);
    const resolution = ctx.type.scope.resolveTypeNode(node);
    const morph = def[2];
    ctx.type.includesMorph = true;
    let domain;
    const result = {};
    for(domain in resolution){
        const predicate = resolution[domain];
        if (predicate === true) {
            result[domain] = {
                rules: {},
                morph
            };
        } else if (typeof predicate === "object") {
            result[domain] = isArray(predicate) ? predicate.map((branch)=>applyMorph(branch, morph)) : applyMorph(predicate, morph);
        } else {
            throwInternalError(`Unexpected predicate value for domain '${domain}': ${stringify(predicate)}`);
        }
    }
    return result;
};
const applyMorph = (branch, morph)=>isTransformationBranch(branch) ? {
        ...branch,
        morph: branch.morph ? Array.isArray(branch.morph) ? [
            ...branch.morph,
            morph
        ] : [
            branch.morph,
            morph
        ] : morph
    } : {
        rules: branch,
        morph
    };
export const writeMalformedMorphExpressionMessage = (value)=>`Morph expression requires a function following '|>' (was ${typeof value})`;
