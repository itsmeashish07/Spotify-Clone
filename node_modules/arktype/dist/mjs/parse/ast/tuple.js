import { rootIntersection, rootUnion, toArrayNode } from "../../nodes/node.js";
import { domainOf } from "../../utils/domains.js";
import { throwParseError } from "../../utils/errors.js";
import { parseDefinition } from "../definition.js";
import { writeMissingRightOperandMessage } from "../string/shift/operand/unenclosed.js";
import { parseConfigTuple } from "./config.js";
import { parseKeyOfTuple } from "./keyof.js";
import { parseMorphTuple } from "./morph.js";
import { parseNarrowTuple } from "./narrow.js";
export const parseTuple = (def, ctx)=>{
    if (isIndexOneExpression(def)) {
        return indexOneParsers[def[1]](def, ctx);
    }
    if (isIndexZeroExpression(def)) {
        return prefixParsers[def[0]](def, ctx);
    }
    const props = {
        //  length is created as a prerequisite prop, ensuring if it is invalid,
        //  no other props will be checked, which is usually desirable for tuple
        //  definitions.
        length: [
            "!",
            {
                number: {
                    value: def.length
                }
            }
        ]
    };
    for(let i = 0; i < def.length; i++){
        ctx.path.push(`${i}`);
        props[i] = parseDefinition(def[i], ctx);
        ctx.path.pop();
    }
    return {
        object: {
            class: Array,
            props
        }
    };
};
const parseBranchTuple = (def, ctx)=>{
    if (def[2] === undefined) {
        return throwParseError(writeMissingRightOperandMessage(def[1], ""));
    }
    const l = parseDefinition(def[0], ctx);
    const r = parseDefinition(def[2], ctx);
    return def[1] === "&" ? rootIntersection(l, r, ctx.type) : rootUnion(l, r, ctx.type);
};
const parseArrayTuple = (def, scope)=>toArrayNode(parseDefinition(def[0], scope));
export const writeMalformedFunctionalExpressionMessage = (operator, rightDef)=>`Expression requires a function following '${operator}' (was ${typeof rightDef})`;
const isIndexOneExpression = (def)=>indexOneParsers[def[1]] !== undefined;
const indexOneParsers = {
    "|": parseBranchTuple,
    "&": parseBranchTuple,
    "[]": parseArrayTuple,
    "=>": parseNarrowTuple,
    "|>": parseMorphTuple,
    ":": parseConfigTuple
};
const prefixParsers = {
    keyof: parseKeyOfTuple,
    instanceof: (def)=>{
        if (typeof def[1] !== "function") {
            return throwParseError(`Expected a constructor following 'instanceof' operator (was ${typeof def[1]}).`);
        }
        return {
            object: {
                class: def[1]
            }
        };
    },
    "===": (def)=>({
            [domainOf(def[1])]: {
                value: def[1]
            }
        }),
    node: (def)=>def[1]
};
const isIndexZeroExpression = (def)=>prefixParsers[def[0]] !== undefined;
