import { mappedKeys } from "../../nodes/rules/props.js";
import { throwInternalError } from "../../utils/errors.js";
import { deepFreeze } from "../../utils/freeze.js";
import { listFrom, objectKeysOf, prototypeKeysOf } from "../../utils/generics.js";
import { tryParseWellFormedInteger, wellFormedNonNegativeIntegerMatcher } from "../../utils/numericLiterals.js";
import { defaultObjectKinds } from "../../utils/objectKinds.js";
import { stringify } from "../../utils/serialize.js";
import { parseDefinition } from "../definition.js";
import { writeImplicitNeverMessage } from "./intersection.js";
const arrayIndexStringBranch = deepFreeze({
    regex: wellFormedNonNegativeIntegerMatcher.source
});
const arrayIndexNumberBranch = deepFreeze({
    range: {
        min: {
            comparator: ">=",
            limit: 0
        }
    },
    divisor: 1
});
export const parseKeyOfTuple = (def, ctx)=>{
    const resolution = ctx.type.scope.resolveNode(parseDefinition(def[1], ctx));
    const predicateKeys = objectKeysOf(resolution).map((domain)=>keysOfPredicate(domain, resolution[domain]));
    const sharedKeys = sharedKeysOf(predicateKeys);
    if (!sharedKeys.length) {
        return writeImplicitNeverMessage(ctx.path, "keyof");
    }
    const keyNode = {};
    for (const key of sharedKeys){
        const keyType = typeof key;
        if (keyType === "string" || keyType === "number" || keyType === "symbol") {
            var _keyNode, _keyType;
            (_keyNode = keyNode)[_keyType = keyType] ?? (_keyNode[_keyType] = []);
            keyNode[keyType].push({
                value: key
            });
        } else if (key === wellFormedNonNegativeIntegerMatcher) {
            var _keyNode1, _keyNode2;
            (_keyNode1 = keyNode).string ?? (_keyNode1.string = []);
            keyNode.string.push(arrayIndexStringBranch);
            (_keyNode2 = keyNode).number ?? (_keyNode2.number = []);
            keyNode.number.push(arrayIndexNumberBranch);
        } else {
            return throwInternalError(`Unexpected keyof key '${stringify(key)}'`);
        }
    }
    return Object.fromEntries(Object.entries(keyNode).map(([domain, branches])=>[
            domain,
            branches.length === 1 ? branches[0] : branches
        ]));
};
const baseKeysByDomain = {
    bigint: prototypeKeysOf(0n),
    boolean: prototypeKeysOf(false),
    null: [],
    number: prototypeKeysOf(0),
    // TS doesn't include the Object prototype in keyof, so keyof object is never
    object: [],
    string: prototypeKeysOf(""),
    symbol: prototypeKeysOf(Symbol()),
    undefined: []
};
const keysOfPredicate = (domain, predicate)=>domain !== "object" || predicate === true ? baseKeysByDomain[domain] : sharedKeysOf(listFrom(predicate).map((branch)=>keysOfObjectBranch(branch)));
const sharedKeysOf = (keyBranches)=>{
    if (!keyBranches.length) {
        return [];
    }
    let sharedKeys = keyBranches[0];
    for(let i = 1; i < keyBranches.length; i++){
        // we can filter directly by equality here because the RegExp we're
        // using will always be reference equal to
        // wellFormedNonNegativeIntegerMatcher
        sharedKeys = sharedKeys.filter((k)=>keyBranches[i].includes(k));
    }
    return sharedKeys;
};
const keysOfObjectBranch = (branch)=>{
    const result = [];
    if ("props" in branch) {
        for (const key of Object.keys(branch.props)){
            if (key === mappedKeys.index) {
                // if any number is a valid key push this RegExp
                result.push(wellFormedNonNegativeIntegerMatcher);
            } else if (!result.includes(key)) {
                result.push(key);
                if (wellFormedNonNegativeIntegerMatcher.test(key)) {
                    // allow numeric access to keys
                    result.push(tryParseWellFormedInteger(key, `Unexpectedly failed to parse an integer from key '${key}'`));
                }
            }
        }
    }
    if ("class" in branch) {
        const constructor = typeof branch.class === "string" ? defaultObjectKinds[branch.class] : branch.class;
        for (const key of prototypeKeysOf(constructor.prototype)){
            if (!result.includes(key)) {
                result.push(key);
            }
        }
    }
    return result;
};
