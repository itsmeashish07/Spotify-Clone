import { isType } from "../scopes/type.js";
import { domainOf } from "../utils/domains.js";
import { throwParseError } from "../utils/errors.js";
import { objectKindOf } from "../utils/objectKinds.js";
import { stringify } from "../utils/serialize.js";
import { parseTuple } from "./ast/tuple.js";
import { parseRecord } from "./record.js";
import { parseString } from "./string/string.js";
export const parseDefinition = (def, ctx)=>{
    const domain = domainOf(def);
    if (domain === "string") {
        return parseString(def, ctx);
    }
    if (domain !== "object") {
        return throwParseError(writeBadDefinitionTypeMessage(domain));
    }
    const objectKind = objectKindOf(def);
    switch(objectKind){
        case "Object":
            return parseRecord(def, ctx);
        case "Array":
            return parseTuple(def, ctx);
        case "RegExp":
            return {
                string: {
                    regex: def.source
                }
            };
        case "Function":
            if (isType(def)) {
                return ctx.type.scope.addAnonymousTypeReference(def, ctx);
            }
            if (isThunk(def)) {
                const returned = def();
                if (isType(returned)) {
                    return ctx.type.scope.addAnonymousTypeReference(returned, ctx);
                }
            }
            return throwParseError(writeBadDefinitionTypeMessage("Function"));
        default:
            return throwParseError(writeBadDefinitionTypeMessage(objectKind ?? stringify(def)));
    }
};
export const as = Symbol("as");
const isThunk = (def)=>typeof def === "function" && def.length === 0;
export const writeBadDefinitionTypeMessage = (actual)=>`Type definitions must be strings or objects (was ${actual})`;
