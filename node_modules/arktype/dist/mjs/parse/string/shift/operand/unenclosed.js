import { tryParseWellFormedBigint, tryParseWellFormedNumber } from "../../../../utils/numericLiterals.js";
export const parseUnenclosed = (s)=>{
    const token = s.scanner.shiftUntilNextTerminator();
    s.setRoot(unenclosedToNode(s, token));
};
const unenclosedToNode = (s, token)=>{
    if (s.ctx.type.scope.addParsedReferenceIfResolvable(token, s.ctx)) {
        return token;
    }
    return maybeParseUnenclosedLiteral(token) ?? s.error(token === "" ? writeMissingOperandMessage(s) : writeUnresolvableMessage(token));
};
const maybeParseUnenclosedLiteral = (token)=>{
    const maybeNumber = tryParseWellFormedNumber(token);
    if (maybeNumber !== undefined) {
        return {
            number: {
                value: maybeNumber
            }
        };
    }
    const maybeBigint = tryParseWellFormedBigint(token);
    if (maybeBigint !== undefined) {
        return {
            bigint: {
                value: maybeBigint
            }
        };
    }
};
export const writeUnresolvableMessage = (token)=>`'${token}' is unresolvable`;
export const writeMissingOperandMessage = (s)=>{
    const operator = s.previousOperator();
    return operator ? writeMissingRightOperandMessage(operator, s.scanner.unscanned) : writeExpressionExpectedMessage(s.scanner.unscanned);
};
export const writeMissingRightOperandMessage = (token, unscanned)=>`Token '${token}' requires a right operand${unscanned ? ` before '${unscanned}'` : ""}`;
export const writeExpressionExpectedMessage = (unscanned)=>`Expected an expression${unscanned ? ` before '${unscanned}'` : ""}`;
