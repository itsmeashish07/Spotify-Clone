import { stringifyRange } from "../../../../nodes/compose.js";
import { compareStrictness, maxComparators, minComparators } from "../../../../nodes/rules/range.js";
import { throwInternalError } from "../../../../utils/errors.js";
import { isKeyOf, listFrom, objectKeysOf } from "../../../../utils/generics.js";
import { tryParseWellFormedNumber } from "../../../../utils/numericLiterals.js";
import { writeUnboundableMessage } from "../../../ast/bound.js";
import { writeUnpairableComparatorMessage } from "../../reduce/shared.js";
import { Scanner } from "../scanner.js";
export const parseBound = (s, start)=>{
    const comparator = shiftComparator(s, start);
    const maybeMin = s.ejectRootIfLimit();
    return maybeMin === undefined ? parseRightBound(s, comparator) : s.reduceLeftBound(maybeMin, comparator);
};
const shiftComparator = (s, start)=>s.scanner.lookaheadIs("=") ? `${start}${s.scanner.shift()}` : isKeyOf(start, Scanner.oneCharComparators) ? start : s.error(singleEqualsMessage);
export const singleEqualsMessage = `= is not a valid comparator. Use == to check for equality`;
export const parseRightBound = (s, comparator)=>{
    const limitToken = s.scanner.shiftUntilNextTerminator();
    const limit = tryParseWellFormedNumber(limitToken, writeInvalidLimitMessage(comparator, limitToken + s.scanner.unscanned));
    const openRange = s.ejectRangeIfOpen();
    const rightBound = {
        comparator,
        limit
    };
    const range = openRange ? !hasComparatorIn(rightBound, maxComparators) ? s.error(writeUnpairableComparatorMessage(comparator)) : compareStrictness("min", openRange, rightBound) === "l" ? s.error(writeEmptyRangeMessage({
        min: openRange,
        max: rightBound
    })) : {
        min: openRange,
        max: rightBound
    } : hasComparator(rightBound, "==") ? rightBound : hasComparatorIn(rightBound, minComparators) ? {
        min: rightBound
    } : hasComparatorIn(rightBound, maxComparators) ? {
        max: rightBound
    } : throwInternalError(`Unexpected comparator '${rightBound.comparator}'`);
    s.intersect(distributeRange(range, s));
};
const distributeRange = (range, s)=>{
    const resolution = s.resolveRoot();
    const domains = objectKeysOf(resolution);
    const distributedRange = {};
    const rangePredicate = {
        range
    };
    const isBoundable = domains.every((domain)=>{
        switch(domain){
            case "string":
                distributedRange.string = rangePredicate;
                return true;
            case "number":
                distributedRange.number = rangePredicate;
                return true;
            case "object":
                distributedRange.object = rangePredicate;
                if (resolution.object === true) {
                    return false;
                }
                return listFrom(resolution.object).every((branch)=>"class" in branch && branch.class === Array);
            default:
                return false;
        }
    });
    if (!isBoundable) {
        s.error(writeUnboundableMessage(s.rootToString()));
    }
    return distributedRange;
};
const hasComparator = (bound, comparator)=>bound.comparator === comparator;
const hasComparatorIn = (bound, comparators)=>bound.comparator in comparators;
export const writeInvalidLimitMessage = (comparator, limit)=>`Comparator ${comparator} must be followed by a number literal (was '${limit}')`;
export const writeEmptyRangeMessage = (range)=>`${stringifyRange(range)} is empty`;
