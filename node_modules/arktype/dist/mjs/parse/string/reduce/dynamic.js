function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
import { isLiteralNode, rootIntersection, rootUnion, toArrayNode } from "../../../nodes/node.js";
import { minComparators } from "../../../nodes/rules/range.js";
import { throwInternalError, throwParseError } from "../../../utils/errors.js";
import { isKeyOf } from "../../../utils/generics.js";
import { stringify } from "../../../utils/serialize.js";
import { Scanner } from "../shift/scanner.js";
import { unclosedGroupMessage, writeMultipleLeftBoundsMessage, writeOpenRangeMessage, writeUnmatchedGroupCloseMessage, writeUnpairableComparatorMessage } from "./shared.js";
export class DynamicState {
    error(message) {
        return throwParseError(message);
    }
    hasRoot() {
        return this.root !== undefined;
    }
    resolveRoot() {
        this.assertHasRoot();
        return this.ctx.type.scope.resolveTypeNode(this.root);
    }
    rootToString() {
        this.assertHasRoot();
        return stringify(this.root);
    }
    ejectRootIfLimit() {
        this.assertHasRoot();
        const resolution = typeof this.root === "string" ? this.ctx.type.scope.resolveNode(this.root) : this.root;
        if (isLiteralNode(resolution, "number")) {
            const limit = resolution.number.value;
            this.root = undefined;
            return limit;
        }
    }
    ejectRangeIfOpen() {
        if (this.branches.range) {
            const range = this.branches.range;
            delete this.branches.range;
            return range;
        }
    }
    assertHasRoot() {
        if (this.root === undefined) {
            return throwInternalError("Unexpected interaction with unset root");
        }
    }
    assertUnsetRoot() {
        if (this.root !== undefined) {
            return throwInternalError("Unexpected attempt to overwrite root");
        }
    }
    setRoot(node) {
        this.assertUnsetRoot();
        this.root = node;
    }
    rootToArray() {
        this.root = toArrayNode(this.ejectRoot());
    }
    intersect(node) {
        this.root = rootIntersection(this.ejectRoot(), node, this.ctx.type);
    }
    ejectRoot() {
        this.assertHasRoot();
        const root = this.root;
        this.root = undefined;
        return root;
    }
    ejectFinalizedRoot() {
        this.assertHasRoot();
        const root = this.root;
        this.root = ejectedProxy;
        return root;
    }
    finalize() {
        if (this.groups.length) {
            return this.error(unclosedGroupMessage);
        }
        this.finalizeBranches();
        this.scanner.finalized = true;
    }
    reduceLeftBound(limit, comparator) {
        const invertedComparator = Scanner.invertedComparators[comparator];
        if (!isKeyOf(invertedComparator, minComparators)) {
            return this.error(writeUnpairableComparatorMessage(comparator));
        }
        if (this.branches.range) {
            return this.error(writeMultipleLeftBoundsMessage(`${this.branches.range.limit}`, this.branches.range.comparator, `${limit}`, invertedComparator));
        }
        this.branches.range = {
            limit,
            comparator: invertedComparator
        };
    }
    finalizeBranches() {
        this.assertRangeUnset();
        if (this.branches.union) {
            this.pushRootToBranch("|");
            this.setRoot(this.branches.union);
        } else if (this.branches.intersection) {
            this.setRoot(rootIntersection(this.branches.intersection, this.ejectRoot(), this.ctx.type));
        }
    }
    finalizeGroup() {
        this.finalizeBranches();
        const topBranchState = this.groups.pop();
        if (!topBranchState) {
            return this.error(writeUnmatchedGroupCloseMessage(this.scanner.unscanned));
        }
        this.branches = topBranchState;
    }
    pushRootToBranch(token) {
        this.assertRangeUnset();
        this.branches.intersection = this.branches.intersection ? rootIntersection(this.branches.intersection, this.ejectRoot(), this.ctx.type) : this.ejectRoot();
        if (token === "|") {
            this.branches.union = this.branches.union ? rootUnion(this.branches.union, this.branches.intersection, this.ctx.type) : this.branches.intersection;
            delete this.branches.intersection;
        }
    }
    assertRangeUnset() {
        if (this.branches.range) {
            return this.error(writeOpenRangeMessage(`${this.branches.range.limit}`, this.branches.range.comparator));
        }
    }
    reduceGroupOpen() {
        this.groups.push(this.branches);
        this.branches = {};
    }
    previousOperator() {
        return this.branches.range?.comparator ?? this.branches.intersection ? "&" : this.branches.union ? "|" : undefined;
    }
    shiftedByOne() {
        this.scanner.shift();
        return this;
    }
    constructor(def, ctx){
        _defineProperty(this, "ctx", void 0);
        _defineProperty(this, "scanner", void 0);
        _defineProperty(this, "root", void 0);
        _defineProperty(this, "branches", void 0);
        _defineProperty(this, "groups", void 0);
        this.ctx = ctx;
        this.branches = {};
        this.groups = [];
        this.scanner = new Scanner(def);
    }
}
const ejectedProxy = new Proxy({}, {
    get: ()=>throwInternalError(`Unexpected attempt to access ejected attributes`)
});
