function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
    return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateFieldInit(obj, privateMap, value) {
    _checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
    _classApplyDescriptorSet(receiver, descriptor, value);
    return value;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
import { throwInternalError } from "../utils/errors.js";
import { objectKeysOf } from "../utils/generics.js";
import { Path } from "../utils/paths.js";
import { stringify } from "../utils/serialize.js";
export const composeIntersection = (reducer)=>(l, r, state)=>l === undefined ? r === undefined ? throwInternalError(undefinedOperandsMessage) : r : r === undefined ? l : reducer(l, r, state);
export const undefinedOperandsMessage = `Unexpected operation two undefined operands`;
export const disjointDescriptionWriters = {
    domain: ({ l , r  })=>`${l.join(", ")} and ${r.join(", ")}`,
    range: ({ l , r  })=>`${stringifyRange(l)} and ${stringifyRange(r)}`,
    class: ({ l , r  })=>`classes ${typeof l === "string" ? l : l.name} and ${typeof r === "string" ? r : r.name}`,
    tupleLength: ({ l , r  })=>`tuples of length ${l} and ${r}`,
    value: ({ l , r  })=>`literal values ${stringify(l)} and ${stringify(r)}`,
    leftAssignability: ({ l , r  })=>`literal value ${stringify(l.value)} and ${stringify(r)}`,
    rightAssignability: ({ l , r  })=>`literal value ${stringify(r.value)} and ${stringify(l)}`,
    union: ({ l , r  })=>`branches ${stringify(l)} and branches ${stringify(r)}`
};
export const stringifyRange = (range)=>"limit" in range ? `the range of exactly ${range.limit}` : range.min ? range.max ? `the range bounded by ${range.min.comparator}${range.min.limit} and ${range.max.comparator}${range.max.limit}` : `${range.min.comparator}${range.min.limit}` : range.max ? `${range.max.comparator}${range.max.limit}` : "the unbounded range";
var _disjoints = /*#__PURE__*/ new WeakMap();
export class IntersectionState {
    get disjoints() {
        return _classPrivateFieldGet(this, _disjoints);
    }
    addDisjoint(kind, l, r) {
        _classPrivateFieldGet(this, _disjoints)[`${this.path}`] = {
            kind,
            l,
            r,
            lOptional: this.lOptional,
            rOptional: this.rOptional
        };
        return empty;
    }
    constructor(type, lastOperator){
        _defineProperty(this, "type", void 0);
        _defineProperty(this, "lastOperator", void 0);
        _defineProperty(this, "path", void 0);
        _defineProperty(this, "lOptional", void 0);
        _defineProperty(this, "rOptional", void 0);
        _defineProperty(this, "domain", void 0);
        _classPrivateFieldInit(this, _disjoints, {
            writable: true,
            value: void 0
        });
        this.type = type;
        this.lastOperator = lastOperator;
        this.path = new Path();
        this.lOptional = false;
        this.rOptional = false;
        _classPrivateFieldSet(this, _disjoints, {});
    }
}
const empty = Symbol("empty");
export const anonymousDisjoint = ()=>empty;
export const isDisjoint = (result)=>result === empty;
const equal = Symbol("equal");
export const equality = ()=>equal;
export const isEquality = (result)=>result === equal;
export const composeKeyedIntersection = (reducer, config)=>(l, r, state)=>{
        const result = {};
        const keys = objectKeysOf({
            ...l,
            ...r
        });
        let lImpliesR = true;
        let rImpliesL = true;
        for (const k of keys){
            const keyResult = typeof reducer === "function" ? reducer(k, l[k], r[k], state) : reducer[k](l[k], r[k], state);
            if (isEquality(keyResult)) {
                if (l[k] !== undefined) {
                    result[k] = l[k];
                }
            } else if (isDisjoint(keyResult)) {
                if (config.onEmpty === "omit") {
                    lImpliesR = false;
                    rImpliesL = false;
                } else {
                    return empty;
                }
            } else {
                if (keyResult !== undefined) {
                    result[k] = keyResult;
                }
                lImpliesR && (lImpliesR = keyResult === l[k]);
                rImpliesL && (rImpliesL = keyResult === r[k]);
            }
        }
        return lImpliesR ? rImpliesL ? equality() : l : rImpliesL ? r : result;
    };
