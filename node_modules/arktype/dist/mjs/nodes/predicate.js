import { listFrom } from "../utils/generics.js";
import { isArray } from "../utils/objectKinds.js";
import { branchIntersection, compareBranches, flattenBranch, isBranchComparison } from "./branch.js";
import { equality, IntersectionState, isEquality } from "./compose.js";
import { flattenBranches } from "./discriminate.js";
const emptyRulesIfTrue = (predicate)=>predicate === true ? {} : predicate;
export const comparePredicates = (l, r, context)=>{
    if (l === true && r === true) {
        return equality();
    }
    if (!isArray(l) && !isArray(r)) {
        const result = branchIntersection(emptyRulesIfTrue(l), emptyRulesIfTrue(r), context);
        return result === l ? l : result === r ? r : result;
    }
    const lBranches = listFrom(emptyRulesIfTrue(l));
    const rBranches = listFrom(emptyRulesIfTrue(r));
    const comparison = compareBranches(lBranches, rBranches, context);
    if (comparison.equalities.length === lBranches.length && comparison.equalities.length === rBranches.length) {
        return equality();
    }
    if (comparison.lExtendsR.length + comparison.equalities.length === lBranches.length) {
        return l;
    }
    if (comparison.rExtendsL.length + comparison.equalities.length === rBranches.length) {
        return r;
    }
    return comparison;
};
export const predicateIntersection = (domain, l, r, state)=>{
    state.domain = domain;
    const comparison = comparePredicates(l, r, state);
    if (!isBranchComparison(comparison)) {
        return comparison;
    }
    const resultBranches = [
        ...comparison.distinctIntersections,
        ...comparison.equalities.map((indices)=>comparison.lBranches[indices[0]]),
        ...comparison.lExtendsR.map((lIndex)=>comparison.lBranches[lIndex]),
        ...comparison.rExtendsL.map((rIndex)=>comparison.rBranches[rIndex])
    ];
    if (resultBranches.length === 0) {
        state.addDisjoint("union", comparison.lBranches, comparison.rBranches);
    }
    return resultBranches.length === 1 ? resultBranches[0] : resultBranches;
};
export const predicateUnion = (domain, l, r, type)=>{
    const state = new IntersectionState(type, "|");
    const comparison = comparePredicates(l, r, state);
    if (!isBranchComparison(comparison)) {
        return isEquality(comparison) || comparison === l ? r : comparison === r ? l : // subtype of the other, it consists of two opposite literals
        // and can be simplified to a non-literal boolean.
        domain === "boolean" ? true : [
            emptyRulesIfTrue(l),
            emptyRulesIfTrue(r)
        ];
    }
    const resultBranches = [
        ...comparison.lBranches.filter((_, lIndex)=>!comparison.lExtendsR.includes(lIndex) && !comparison.equalities.some((indexPair)=>indexPair[0] === lIndex)),
        ...comparison.rBranches.filter((_, rIndex)=>!comparison.rExtendsL.includes(rIndex) && !comparison.equalities.some((indexPair)=>indexPair[1] === rIndex))
    ];
    return resultBranches.length === 1 ? resultBranches[0] : resultBranches;
};
export const flattenPredicate = (predicate, context)=>{
    if (predicate === true) {
        return [];
    }
    return isArray(predicate) ? flattenBranches(predicate, context) : flattenBranch(predicate, context);
};
export const isLiteralCondition = (predicate)=>typeof predicate === "object" && "value" in predicate;
