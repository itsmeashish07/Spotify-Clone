import { sizeOf } from "../../utils/data.js";
import { composeIntersection, equality } from "../compose.js";
export const minComparators = {
    ">": true,
    ">=": true
};
export const maxComparators = {
    "<": true,
    "<=": true
};
export const isEqualityRange = (range)=>"comparator" in range;
export const rangeIntersection = composeIntersection((l, r, state)=>{
    if (isEqualityRange(l)) {
        if (isEqualityRange(r)) {
            return l.limit === r.limit ? equality() : state.addDisjoint("range", l, r);
        }
        return rangeAllows(r, l.limit) ? l : state.addDisjoint("range", l, r);
    }
    if (isEqualityRange(r)) {
        return rangeAllows(l, r.limit) ? r : state.addDisjoint("range", l, r);
    }
    const stricterMin = compareStrictness("min", l.min, r.min);
    const stricterMax = compareStrictness("max", l.max, r.max);
    if (stricterMin === "l") {
        if (stricterMax === "r") {
            return compareStrictness("min", l.min, r.max) === "l" ? state.addDisjoint("range", l, r) : {
                min: l.min,
                max: r.max
            };
        }
        return l;
    }
    if (stricterMin === "r") {
        if (stricterMax === "l") {
            return compareStrictness("max", l.max, r.min) === "l" ? state.addDisjoint("range", l, r) : {
                min: r.min,
                max: l.max
            };
        }
        return r;
    }
    return stricterMax === "l" ? l : stricterMax === "r" ? r : equality();
});
const rangeAllows = (range, n)=>isEqualityRange(range) ? n === range.limit : minAllows(range.min, n) && maxAllows(range.max, n);
const minAllows = (min, n)=>!min || n > min.limit || n === min.limit && !isExclusive(min.comparator);
const maxAllows = (max, n)=>!max || n < max.limit || n === max.limit && !isExclusive(max.comparator);
export const flattenRange = (entries, range, ctx)=>{
    const units = ctx.lastDomain === "string" ? "characters" : ctx.lastDomain === "object" ? "items long" : undefined;
    if (isEqualityRange(range)) {
        return entries.push([
            "bound",
            units ? {
                ...range,
                units
            } : range
        ]);
    }
    if (range.min) {
        entries.push([
            "bound",
            units ? {
                ...range.min,
                units
            } : range.min
        ]);
    }
    if (range.max) {
        entries.push([
            "bound",
            units ? {
                ...range.max,
                units
            } : range.max
        ]);
    }
};
export const checkBound = (bound, state)=>comparatorCheckers[bound.comparator](sizeOf(state.data), bound.limit) || !state.problems.add("bound", bound);
const comparatorCheckers = {
    "<": (size, limit)=>size < limit,
    ">": (size, limit)=>size > limit,
    "<=": (size, limit)=>size <= limit,
    ">=": (size, limit)=>size >= limit,
    "==": (size, limit)=>size === limit
};
export const compareStrictness = (kind, l, r)=>!l ? !r ? "=" : "r" : !r ? "l" : l.limit === r.limit ? isExclusive(l.comparator) ? isExclusive(r.comparator) ? "=" : "l" : isExclusive(r.comparator) ? "r" : "=" : kind === "min" ? l.limit > r.limit ? "l" : "r" : l.limit < r.limit ? "l" : "r";
const isExclusive = (comparator)=>comparator.length === 1;
