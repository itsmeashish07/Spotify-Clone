import { listFrom } from "../../utils/generics.js";
import { composeIntersection, composeKeyedIntersection, equality } from "../compose.js";
import { classIntersection } from "./class.js";
import { collapsibleListUnion } from "./collapsibleSet.js";
import { divisorIntersection } from "./divisor.js";
import { flattenProps, propsIntersection } from "./props.js";
import { flattenRange, rangeIntersection } from "./range.js";
import { regexIntersection } from "./regex.js";
export const rulesIntersection = (l, r, state)=>"value" in l ? "value" in r ? l.value === r.value ? equality() : state.addDisjoint("value", l.value, r.value) : literalSatisfiesRules(l.value, r, state) ? l : state.addDisjoint("leftAssignability", l, r) : "value" in r ? literalSatisfiesRules(r.value, l, state) ? r : state.addDisjoint("rightAssignability", l, r) : narrowableRulesIntersection(l, r, state);
const narrowIntersection = composeIntersection(collapsibleListUnion);
export const narrowableRulesIntersection = composeKeyedIntersection({
    divisor: divisorIntersection,
    regex: regexIntersection,
    props: propsIntersection,
    class: classIntersection,
    range: rangeIntersection,
    narrow: narrowIntersection
}, {
    onEmpty: "bubble"
});
export const flattenRules = (rules, ctx)=>{
    const entries = [];
    let k;
    for(k in rules){
        ruleFlatteners[k](entries, rules[k], ctx);
    }
    // Some entries with the same precedence, e.g. morphs flattened from a list,
    // rely on the fact that JS's builtin sort is stable to behave as expected
    // when traversed:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
    return entries.sort((l, r)=>precedenceMap[l[0]] - precedenceMap[r[0]]);
};
const ruleFlatteners = {
    regex: (entries, rule)=>{
        for (const source of listFrom(rule)){
            entries.push([
                "regex",
                source
            ]);
        }
    },
    divisor: (entries, rule)=>{
        entries.push([
            "divisor",
            rule
        ]);
    },
    range: flattenRange,
    class: (entries, rule)=>{
        entries.push([
            "class",
            rule
        ]);
    },
    props: flattenProps,
    narrow: (entries, rule)=>{
        for (const narrow of listFrom(rule)){
            entries.push([
                "narrow",
                narrow
            ]);
        }
    },
    value: (entries, rule)=>{
        entries.push([
            "value",
            rule
        ]);
    }
};
export const precedenceMap = {
    // Config: Applies before any checks
    config: -1,
    // Critical: No other checks are performed if these fail
    domain: 0,
    value: 0,
    domains: 0,
    branches: 0,
    switch: 0,
    alias: 0,
    class: 0,
    // Shallow: All shallow checks will be performed even if one or more fail
    regex: 1,
    divisor: 1,
    bound: 1,
    // Prerequisite: These are deep checks with special priority, e.g. the
    // length of a tuple, which causes other deep props not to be checked if it
    // is invalid
    prerequisiteProp: 2,
    // Deep: Performed if all shallow checks pass, even if one or more deep checks fail
    distilledProps: 3,
    strictProps: 3,
    requiredProp: 3,
    optionalProp: 3,
    indexProp: 3,
    // Narrow: Only performed if all shallow and deep checks pass
    narrow: 4,
    // Morph: Only performed if all validation passes
    morph: 5
};
export const literalSatisfiesRules = (data, rules, state)=>!state.type.scope.type([
        "node",
        {
            [state.domain]: rules
        }
    ])(data).problems;
