import { compileDisjointReasonsMessage } from "../parse/ast/intersection.js";
import { throwInternalError, throwParseError } from "../utils/errors.js";
import { entriesOf, hasKey, hasKeys, objectKeysOf } from "../utils/generics.js";
import { Path } from "../utils/paths.js";
import { anonymousDisjoint, composeKeyedIntersection, IntersectionState, isDisjoint, isEquality, undefinedOperandsMessage } from "./compose.js";
import { flattenPredicate, isLiteralCondition, predicateIntersection, predicateUnion } from "./predicate.js";
import { mappedKeys } from "./rules/props.js";
export const isConfigNode = (node)=>"config" in node;
export const nodeIntersection = (l, r, state)=>{
    state.domain = undefined;
    const lDomains = state.type.scope.resolveTypeNode(l);
    const rDomains = state.type.scope.resolveTypeNode(r);
    const result = typeNodeIntersection(lDomains, rDomains, state);
    if (typeof result === "object" && !hasKeys(result)) {
        return hasKeys(state.disjoints) ? anonymousDisjoint() : state.addDisjoint("domain", objectKeysOf(lDomains), objectKeysOf(rDomains));
    }
    return result === lDomains ? l : result === rDomains ? r : result;
};
const typeNodeIntersection = composeKeyedIntersection((domain, l, r, context)=>{
    if (l === undefined) {
        return r === undefined ? throwInternalError(undefinedOperandsMessage) : undefined;
    }
    if (r === undefined) {
        return undefined;
    }
    return predicateIntersection(domain, l, r, context);
}, {
    onEmpty: "omit"
});
export const rootIntersection = (l, r, type)=>{
    const state = new IntersectionState(type, "&");
    const result = nodeIntersection(l, r, state);
    return isDisjoint(result) ? throwParseError(compileDisjointReasonsMessage(state.disjoints)) : isEquality(result) ? l : result;
};
export const rootUnion = (l, r, type)=>{
    const lDomains = type.scope.resolveTypeNode(l);
    const rDomains = type.scope.resolveTypeNode(r);
    const result = {};
    const domains = objectKeysOf({
        ...lDomains,
        ...rDomains
    });
    for (const domain of domains){
        result[domain] = hasKey(lDomains, domain) ? hasKey(rDomains, domain) ? predicateUnion(domain, lDomains[domain], rDomains[domain], type) : lDomains[domain] : hasKey(rDomains, domain) ? rDomains[domain] : throwInternalError(undefinedOperandsMessage);
    }
    return result;
};
const hasImpliedDomain = (flatPredicate)=>flatPredicate[0] && (flatPredicate[0][0] === "value" || flatPredicate[0][0] === "class");
export const flattenType = (type)=>{
    const ctx = {
        type,
        path: new Path(),
        lastDomain: "undefined"
    };
    return flattenNode(type.node, ctx);
};
export const flattenNode = (node, ctx)=>{
    if (typeof node === "string") {
        return ctx.type.scope.resolve(node).flat;
    }
    const hasConfig = isConfigNode(node);
    const flattenedTypeNode = flattenTypeNode(hasConfig ? node.node : node, ctx);
    return hasConfig ? [
        [
            "config",
            {
                config: entriesOf(node.config),
                node: flattenedTypeNode
            }
        ]
    ] : flattenedTypeNode;
};
export const flattenTypeNode = (node, ctx)=>{
    const domains = objectKeysOf(node);
    if (domains.length === 1) {
        const domain = domains[0];
        const predicate = node[domain];
        if (predicate === true) {
            return domain;
        }
        ctx.lastDomain = domain;
        const flatPredicate = flattenPredicate(predicate, ctx);
        return hasImpliedDomain(flatPredicate) ? flatPredicate : [
            [
                "domain",
                domain
            ],
            ...flatPredicate
        ];
    }
    const result = {};
    for (const domain of domains){
        ctx.lastDomain = domain;
        result[domain] = flattenPredicate(node[domain], ctx);
    }
    return [
        [
            "domains",
            result
        ]
    ];
};
export const isLiteralNode = (node, domain)=>{
    return resolutionExtendsDomain(node, domain) && isLiteralCondition(node[domain]);
};
export const resolutionExtendsDomain = (resolution, domain)=>{
    const domains = objectKeysOf(resolution);
    return domains.length === 1 && domains[0] === domain;
};
export const toArrayNode = (node)=>({
        object: {
            class: Array,
            props: {
                [mappedKeys.index]: node
            }
        }
    });
