function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
    return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateFieldInit(obj, privateMap, value) {
    _checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
    _classApplyDescriptorSet(receiver, descriptor, value);
    return value;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
import { serializeCase } from "../nodes/discriminate.js";
import { checkClass } from "../nodes/rules/class.js";
import { checkDivisor } from "../nodes/rules/divisor.js";
import { checkBound } from "../nodes/rules/range.js";
import { checkRegex } from "../nodes/rules/regex.js";
import { precedenceMap } from "../nodes/rules/rules.js";
import { domainOf, hasDomain } from "../utils/domains.js";
import { throwInternalError } from "../utils/errors.js";
import { hasKey, objectKeysOf } from "../utils/generics.js";
import { wellFormedIntegerMatcher } from "../utils/numericLiterals.js";
import { getPath, Path } from "../utils/paths.js";
import { domainsToDescriptions, objectKindsToDescriptions, Problem, Problems } from "./problems.js";
const initializeTraversalConfig = ()=>({
        mustBe: [],
        writeReason: [],
        addContext: [],
        keys: []
    });
const problemWriterKeys = [
    "mustBe",
    "writeReason",
    "addContext"
];
export const traverseRoot = (t, data)=>{
    const state = new TraversalState(data, t);
    traverse(t.flat, state);
    const result = new CheckResult(state);
    if (state.problems.count) {
        result.problems = state.problems;
    } else {
        for (const [o, k] of state.entriesToPrune){
            delete o[k];
        }
        result.data = state.data;
    }
    return result;
};
const CheckResult = class {
    constructor(){
        _defineProperty(this, "data", void 0);
        _defineProperty(this, "problems", void 0);
    }
};
var _seen = /*#__PURE__*/ new WeakMap();
export class TraversalState {
    getProblemConfig(code) {
        const result = {};
        for (const k of problemWriterKeys){
            result[k] = this.traversalConfig[k][0] ?? this.rootScope.config.codes[code][k];
        }
        return result;
    }
    traverseConfig(configEntries, node) {
        for (const entry of configEntries){
            this.traversalConfig[entry[0]].unshift(entry[1]);
        }
        const isValid = traverse(node, this);
        for (const entry of configEntries){
            this.traversalConfig[entry[0]].shift();
        }
        return isValid;
    }
    traverseKey(key, node) {
        const lastData = this.data;
        this.data = this.data[key];
        this.path.push(key);
        const isValid = traverse(node, this);
        this.path.pop();
        if (lastData[key] !== this.data) {
            lastData[key] = this.data;
        }
        this.data = lastData;
        return isValid;
    }
    traverseResolution(name) {
        const resolution = this.type.scope.resolve(name);
        const id = resolution.qualifiedName;
        // this assignment helps with narrowing
        const data = this.data;
        const isObject = hasDomain(data, "object");
        if (isObject) {
            const seenByCurrentType = _classPrivateFieldGet(this, _seen)[id];
            if (seenByCurrentType) {
                if (seenByCurrentType.includes(data)) {
                    // if data has already been checked by this alias as part of
                    // a resolution higher up on the call stack, it must be valid
                    // or we wouldn't be here
                    return true;
                }
                seenByCurrentType.push(data);
            } else {
                _classPrivateFieldGet(this, _seen)[id] = [
                    data
                ];
            }
        }
        const lastType = this.type;
        this.type = resolution;
        const isValid = traverse(resolution.flat, this);
        this.type = lastType;
        if (isObject) {
            _classPrivateFieldGet(this, _seen)[id].pop();
        }
        return isValid;
    }
    traverseBranches(branches) {
        const lastFailFast = this.failFast;
        this.failFast = true;
        const lastProblems = this.problems;
        const branchProblems = new Problems(this);
        this.problems = branchProblems;
        const lastPath = this.path;
        const lastKeysToPrune = this.entriesToPrune;
        let hasValidBranch = false;
        for (const branch of branches){
            this.path = new Path();
            this.entriesToPrune = [];
            if (checkEntries(branch, this)) {
                hasValidBranch = true;
                lastKeysToPrune.push(...this.entriesToPrune);
                break;
            }
        }
        this.path = lastPath;
        this.entriesToPrune = lastKeysToPrune;
        this.problems = lastProblems;
        this.failFast = lastFailFast;
        return hasValidBranch || !this.problems.add("branches", branchProblems);
    }
    constructor(data, type){
        _defineProperty(this, "data", void 0);
        _defineProperty(this, "type", void 0);
        _defineProperty(this, "path", void 0);
        _defineProperty(this, "problems", void 0);
        _defineProperty(this, "entriesToPrune", void 0);
        _defineProperty(this, "failFast", void 0);
        _defineProperty(this, "traversalConfig", void 0);
        _defineProperty(this, "rootScope", void 0);
        _classPrivateFieldInit(this, _seen, {
            writable: true,
            value: void 0
        });
        this.data = data;
        this.type = type;
        this.path = new Path();
        this.problems = new Problems(this);
        this.entriesToPrune = [];
        this.failFast = false;
        this.traversalConfig = initializeTraversalConfig();
        _classPrivateFieldSet(this, _seen, {});
        this.rootScope = type.scope;
    }
}
export const traverse = (node, state)=>typeof node === "string" ? domainOf(state.data) === node || !state.problems.add("domain", node) : checkEntries(node, state);
export const checkEntries = (entries, state)=>{
    let isValid = true;
    for(let i = 0; i < entries.length; i++){
        const [k, v] = entries[i];
        const entryAllowsData = entryCheckers[k](v, state);
        isValid && (isValid = entryAllowsData);
        if (!isValid) {
            if (state.failFast) {
                return false;
            }
            if (i < entries.length - 1 && precedenceMap[k] < precedenceMap[entries[i + 1][0]]) {
                // if we've encountered a problem, there is at least one entry
                // remaining, and the next entry is of a higher precedence level
                // than the current entry, return immediately
                return false;
            }
        }
    }
    return isValid;
};
export const checkRequiredProp = (prop, state)=>{
    if (prop[0] in state.data) {
        return state.traverseKey(prop[0], prop[1]);
    }
    state.problems.add("missing", undefined, {
        path: state.path.concat(prop[0]),
        data: undefined
    });
    return false;
};
const createPropChecker = (kind)=>(props, state)=>{
        let isValid = true;
        const remainingUnseenRequired = {
            ...props.required
        };
        for(const k in state.data){
            if (props.required[k]) {
                isValid = state.traverseKey(k, props.required[k]) && isValid;
                delete remainingUnseenRequired[k];
            } else if (props.optional[k]) {
                isValid = state.traverseKey(k, props.optional[k]) && isValid;
            } else if (props.index && wellFormedIntegerMatcher.test(k)) {
                isValid = state.traverseKey(k, props.index) && isValid;
            } else if (kind === "distilledProps") {
                if (state.failFast) {
                    // If we're in a union (i.e. failFast is enabled) in
                    // distilled mode, we need to wait to prune distilled keys
                    // to avoid mutating data based on a branch that will not be
                    // included in the final result. Instead, we push the object
                    // and key to state to handle after traversal is complete.
                    state.entriesToPrune.push([
                        state.data,
                        k
                    ]);
                } else {
                    // If we're not in a union, we can safely distill right away
                    delete state.data[k];
                }
            } else {
                isValid = false;
                state.problems.add("extraneous", state.data[k], {
                    path: state.path.concat(k)
                });
            }
            if (!isValid && state.failFast) {
                return false;
            }
        }
        const unseenRequired = Object.keys(remainingUnseenRequired);
        if (unseenRequired.length) {
            for (const k of unseenRequired){
                state.problems.add("missing", undefined, {
                    path: state.path.concat(k)
                });
            }
            return false;
        }
        return isValid;
    };
const entryCheckers = {
    regex: checkRegex,
    divisor: checkDivisor,
    domains: (domains, state)=>{
        const entries = domains[domainOf(state.data)];
        return entries ? checkEntries(entries, state) : !state.problems.add("cases", domainsToDescriptions(objectKeysOf(domains)));
    },
    domain: (domain, state)=>domainOf(state.data) === domain || !state.problems.add("domain", domain),
    bound: checkBound,
    optionalProp: (prop, state)=>{
        if (prop[0] in state.data) {
            return state.traverseKey(prop[0], prop[1]);
        }
        return true;
    },
    // these checks work the same way, the keys are only distinct so that
    // prerequisite props can have a higher precedence
    requiredProp: checkRequiredProp,
    prerequisiteProp: checkRequiredProp,
    indexProp: (node, state)=>{
        if (!Array.isArray(state.data)) {
            state.problems.add("class", Array);
            return false;
        }
        let isValid = true;
        for(let i = 0; i < state.data.length; i++){
            isValid = state.traverseKey(`${i}`, node) && isValid;
            if (!isValid && state.failFast) {
                return false;
            }
        }
        return isValid;
    },
    branches: (branches, state)=>state.traverseBranches(branches),
    switch: (rule, state)=>{
        const dataAtPath = getPath(state.data, rule.path);
        const caseKey = serializeCase(rule.kind, dataAtPath);
        if (hasKey(rule.cases, caseKey)) {
            return checkEntries(rule.cases[caseKey], state);
        }
        const caseKeys = objectKeysOf(rule.cases);
        const missingCasePath = state.path.concat(rule.path);
        const caseDescriptions = rule.kind === "value" ? caseKeys : rule.kind === "domain" ? domainsToDescriptions(caseKeys) : rule.kind === "class" ? objectKindsToDescriptions(caseKeys) : throwInternalError(`Unexpectedly encountered rule kind '${rule.kind}' during traversal`);
        state.problems.add("cases", caseDescriptions, {
            path: missingCasePath,
            data: dataAtPath
        });
        return false;
    },
    alias: (name, state)=>state.traverseResolution(name),
    class: checkClass,
    narrow: (narrow, state)=>{
        const lastProblemsCount = state.problems.count;
        const result = narrow(state.data, state.problems);
        if (!result && state.problems.count === lastProblemsCount) {
            state.problems.mustBe(narrow.name ? `valid according to ${narrow.name}` : "valid");
        }
        return result;
    },
    config: ({ config , node  }, state)=>state.traverseConfig(config, node),
    value: (value, state)=>state.data === value || !state.problems.add("value", value),
    morph: (morph, state)=>{
        const out = morph(state.data, state.problems);
        if (state.problems.length) {
            return false;
        }
        if (out instanceof Problem) {
            // if a problem was returned from the morph but not added, add it
            state.problems.addProblem(out);
            return false;
        }
        if (out instanceof CheckResult) {
            if (out.problems) {
                for (const problem of out.problems){
                    state.problems.addProblem(problem);
                }
                return false;
            }
            state.data = out.data;
            return true;
        }
        state.data = out;
        return true;
    },
    distilledProps: createPropChecker("distilledProps"),
    strictProps: createPropChecker("strictProps")
};
