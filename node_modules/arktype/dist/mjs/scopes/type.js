import { traverseRoot } from "../traverse/traverse.js";
import { chainableNoOpProxy } from "../utils/chainableNoOpProxy.js";
export const initializeType = (name, definition, config, scope)=>{
    const root = {
        // temporarily initialize node/flat to aliases that will be included in
        // the final type in case of cyclic resolutions
        node: name,
        flat: [
            [
                "alias",
                name
            ]
        ],
        allows: (data)=>!namedTraverse(data).problems,
        assert: (data)=>{
            const result = namedTraverse(data);
            return result.problems ? result.problems.throw() : result.data;
        },
        infer: chainableNoOpProxy,
        inferIn: chainableNoOpProxy,
        qualifiedName: isAnonymousName(name) ? scope.getAnonymousQualifiedName(name) : `${scope.name}.${name}`,
        definition,
        scope,
        includesMorph: false,
        config
    };
    // define within a key to dynamically assign a name to the function
    const namedTraverse = {
        [name]: (data)=>traverseRoot(namedTraverse, data)
    }[name];
    const t = Object.assign(namedTraverse, root);
    return t;
};
export const isType = (value)=>value?.infer === chainableNoOpProxy;
export const isAnonymousName = (name)=>name[0] === "Î»";
