export type BigintLiteral<Value extends bigint = bigint> = `${Value}n`;
export type NumberLiteral<Value extends number = number> = `${Value}`;
export type IntegerLiteral<Value extends bigint = bigint> = `${Value}`;
/**
 * The goal of the number literal and bigint literal regular expressions is to:
 *
 *   1. Ensure definitions form a bijection with the values they represent.
 *   2. Attempt to mirror TypeScript's own format for stringification of numeric
 *      values such that the regex should match a given definition if any only if
 *      a precise literal type will be inferred (in TS4.8+).
 */
/**
 *  Matches a well-formatted numeric expression according to the following rules:
 *    1. Must include an integer portion (i.e. '.321' must be written as '0.321')
 *    2. The first digit of the value must not be 0, unless the entire integer portion is 0
 *    3. If the value includes a decimal, its last digit may not be 0
 *    4. The value may not be "-0"
 */
export declare const wellFormedNumberMatcher: RegExp;
/**
 *  Matches a well-formatted integer according to the following rules:
 *    1. Must begin with an integer, the first digit of which cannot be 0 unless the entire value is 0
 *    2. The value may not be "-0"
 */
export declare const wellFormedIntegerMatcher: RegExp;
export declare const isWellFormedInteger: (s: string) => boolean;
export declare const wellFormedNonNegativeIntegerMatcher: RegExp;
type NumericLiteralKind = "number" | "bigint" | "integer";
declare const numericLiteralDescriptions: {
    readonly number: "a number";
    readonly bigint: "a bigint";
    readonly integer: "an integer";
};
type numericLiteralDescriptions = typeof numericLiteralDescriptions;
export type writeMalformedNumericLiteralMessage<def extends string, kind extends NumericLiteralKind> = `'${def}' was parsed as ${numericLiteralDescriptions[kind]} but could not be narrowed to a literal value. Avoid unnecessary leading or trailing zeros and other abnormal notation`;
export declare const writeMalformedNumericLiteralMessage: <def extends string, kind extends NumericLiteralKind>(def: def, kind: kind) => `'${def}' was parsed as ${{
    readonly number: "a number";
    readonly bigint: "a bigint";
    readonly integer: "an integer";
}[kind]} but could not be narrowed to a literal value. Avoid unnecessary leading or trailing zeros and other abnormal notation`;
export declare const tryParseWellFormedNumber: <ErrorOnFail extends string | boolean>(token: string, errorOnFail?: ErrorOnFail | undefined) => ErrorOnFail extends string | true ? number : number | undefined;
export type tryParseWellFormedNumber<token extends string, messageOnFail extends string> = token extends NumberLiteral<infer value> ? value : messageOnFail;
export declare const tryParseWellFormedInteger: <errorOnFail extends string | boolean>(token: string, errorOnFail?: errorOnFail | undefined) => errorOnFail extends string | true ? number : number | undefined;
export type tryParseWellFormedInteger<token extends string, messageOnFail extends string> = token extends IntegerLiteral<infer value> ? `${value}` extends NumberLiteral<infer valueAsNumber> ? valueAsNumber : never : messageOnFail;
export declare const tryParseWellFormedBigint: (def: string) => bigint | undefined;
export {};
