export declare const asConst: <t>(t: { [k in keyof t]: t[k] extends [] | Literalable ? t[k] : t[k] extends infer T ? { [k_1 in keyof T]: t[k][k_1] extends [] | Literalable ? t[k][k_1] : t[k][k_1] extends infer T_1 ? { [k_2 in keyof T_1]: t[k][k_1][k_2] extends [] | Literalable ? t[k][k_1][k_2] : t[k][k_1][k_2] extends infer T_2 ? { [k_3 in keyof T_2]: t[k][k_1][k_2][k_3] extends [] | Literalable ? t[k][k_1][k_2][k_3] : t[k][k_1][k_2][k_3] extends infer T_3 ? { [k_4 in keyof T_3]: t[k][k_1][k_2][k_3][k_4] extends [] | Literalable ? t[k][k_1][k_2][k_3][k_4] : t[k][k_1][k_2][k_3][k_4] extends infer T_4 ? { [k_5 in keyof T_4]: t[k][k_1][k_2][k_3][k_4][k_5] extends [] | Literalable ? t[k][k_1][k_2][k_3][k_4][k_5] : t[k][k_1][k_2][k_3][k_4][k_5] extends infer T_5 ? { [k_6 in keyof T_5]: t[k][k_1][k_2][k_3][k_4][k_5][k_6] extends [] | Literalable ? t[k][k_1][k_2][k_3][k_4][k_5][k_6] : t[k][k_1][k_2][k_3][k_4][k_5][k_6] extends infer T_6 ? { [k_7 in keyof T_6]: t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7] extends [] | Literalable ? t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7] : t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7] extends infer T_7 ? { [k_8 in keyof T_7]: t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7][k_8] extends [] | Literalable ? t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7][k_8] : t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7][k_8] extends infer T_8 ? { [k_9 in keyof T_8]: t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7][k_8][k_9] extends [] | Literalable ? t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7][k_8][k_9] : t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7][k_8][k_9] extends infer T_9 ? { [k_10 in keyof T_9]: t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7][k_8][k_9][k_10] extends [] | Literalable ? t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7][k_8][k_9][k_10] : any; } : never; } : never; } : never; } : never; } : never; } : never; } : never; } : never; } : never; } : never; }) => { [k in keyof t]: t[k] extends [] | Literalable ? t[k] : t[k] extends infer T ? { [k_1 in keyof T]: t[k][k_1] extends [] | Literalable ? t[k][k_1] : t[k][k_1] extends infer T_1 ? { [k_2 in keyof T_1]: t[k][k_1][k_2] extends [] | Literalable ? t[k][k_1][k_2] : t[k][k_1][k_2] extends infer T_2 ? { [k_3 in keyof T_2]: t[k][k_1][k_2][k_3] extends [] | Literalable ? t[k][k_1][k_2][k_3] : t[k][k_1][k_2][k_3] extends infer T_3 ? { [k_4 in keyof T_3]: t[k][k_1][k_2][k_3][k_4] extends [] | Literalable ? t[k][k_1][k_2][k_3][k_4] : t[k][k_1][k_2][k_3][k_4] extends infer T_4 ? { [k_5 in keyof T_4]: t[k][k_1][k_2][k_3][k_4][k_5] extends [] | Literalable ? t[k][k_1][k_2][k_3][k_4][k_5] : t[k][k_1][k_2][k_3][k_4][k_5] extends infer T_5 ? { [k_6 in keyof T_5]: t[k][k_1][k_2][k_3][k_4][k_5][k_6] extends [] | Literalable ? t[k][k_1][k_2][k_3][k_4][k_5][k_6] : t[k][k_1][k_2][k_3][k_4][k_5][k_6] extends infer T_6 ? { [k_7 in keyof T_6]: t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7] extends [] | Literalable ? t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7] : t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7] extends infer T_7 ? { [k_8 in keyof T_7]: t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7][k_8] extends [] | Literalable ? t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7][k_8] : t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7][k_8] extends infer T_8 ? { [k_9 in keyof T_8]: t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7][k_8][k_9] extends [] | Literalable ? t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7][k_8][k_9] : t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7][k_8][k_9] extends infer T_9 ? { [k_10 in keyof T_9]: t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7][k_8][k_9][k_10] extends [] | Literalable ? t[k][k_1][k_2][k_3][k_4][k_5][k_6][k_7][k_8][k_9][k_10] : any; } : never; } : never; } : never; } : never; } : never; } : never; } : never; } : never; } : never; } : never; };
export type asConst<t> = castWithExclusion<t, asConstRecurse<t>, []>;
type asConstRecurse<t> = {
    [k in keyof t]: t[k] extends Literalable | [] ? t[k] : asConstRecurse<t[k]>;
} & unknown;
export type castWithExclusion<t, castTo, excluded> = t extends excluded ? t : castTo;
export type Literalable = string | boolean | number | bigint;
export type evaluateObjectOrFunction<t> = isTopType<t> extends true ? t : t extends (...args: infer args) => infer ret ? (...args: args) => ret : evaluate<t>;
export type evaluate<t> = {
    [k in keyof t]: t[k];
} & unknown;
/** Causes a type that would be eagerly calculated to be displayed as-is.
 *  WARNING: Makes t NonNullable as a side effect.
 */
export type defer<t> = t & {};
export type merge<base, merged> = evaluate<Omit<base, keyof merged> & merged>;
/** Replace existing keys of o without altering readonly or optional modifiers  */
export type replaceProps<o, replacements extends {
    -readonly [k in keyof o]?: unknown;
}> = evaluate<{
    [k in keyof o]: k extends keyof replacements ? replacements[k] : o[k];
}>;
export type isTopType<t> = (any extends t ? true : false) extends true ? true : false;
export type isAny<t> = (any extends t ? topTypeIsAny<t> : false) extends true ? true : false;
export type isUnknown<t> = (any extends t ? topTypeIsUnknown<t> : false) extends true ? true : false;
type topTypeIsAny<t> = (t extends {} ? true : false) extends false ? false : true;
type topTypeIsUnknown<t> = (t extends {} ? true : false) extends false ? true : false;
export type extractKeysWithValue<o, filter> = {
    [k in keyof o]: isAny<o[k]> extends true ? never : o[k] extends never ? never : o[k] extends filter ? k : never;
}[keyof o];
export type extractValues<o, filter> = o[extractKeysWithValue<o, filter>];
export type conform<t, base> = t extends base ? t : base;
export declare const isKeyOf: <k extends string | number, obj extends object>(k: k, obj: obj) => k is Extract<keyof obj, k>;
export type constructor<instance = unknown> = abstract new (...args: any[]) => instance;
export type instanceOf<classType extends constructor<any>> = classType extends constructor<infer Instance> ? Instance : never;
export type entryOf<o> = evaluate<{
    [k in keyof o]-?: [k, defined<o[k]>];
}[o extends List ? keyof o & number : keyof o]>;
export type entriesOf<o extends object> = entryOf<o>[];
export declare const entriesOf: <o extends object>(o: o) => entriesOf<o>;
/** Mimics the result of Object.keys(...) */
export type objectKeysOf<o> = [o] extends [object] ? o extends readonly unknown[] ? any[] extends o ? `${number}` : keyof o & `${number}` : keyof o extends number ? `${keyof o}` : Exclude<keyof o, symbol> : never;
export declare const objectKeysOf: <o extends object>(o: o) => objectKeysOf<o>[];
export type stringKeyOf<o> = keyof o & string;
/** Mimics output of TS's keyof operator at runtime */
export declare const prototypeKeysOf: <t>(value: t) => (keyof t)[];
export declare const hasKey: <o, k extends string>(o: o, k: k) => o is Extract<o, { [_ in k]: {}; }>;
export declare const hasSingleKey: <o extends object, k extends string>(o: o, k: k) => o is o & { [_ in k]: {}; };
export declare const keyCount: (o: object) => number;
export type keySet<key extends string = string> = {
    readonly [_ in key]?: true;
};
export declare const hasKeys: (value: unknown) => boolean;
export type mutable<o> = {
    -readonly [k in keyof o]: o[k];
};
export type immutable<o> = {
    readonly [k in keyof o]: o[k];
};
export type deepImmutable<o> = [o] extends [object] ? {
    readonly [k in keyof o]: deepImmutable<o[k]>;
} : o;
/** Check for type equality without breaking TS for this repo. Fails on some types like Dict/{} */
export type equals<t, u> = identity<t> extends identity<u> ? true : false;
declare const id: unique symbol;
export declare const nominal: <o extends object, name extends string>(o: o, name: name) => nominal<o, name>;
export type nominal<t, id extends string> = t & {
    readonly [id]: id;
};
export declare const getNominalId: <data>(data: data) => unknown;
export declare const hasNominalId: <data, name extends string>(data: data, name: name) => data is nominal<data, name>;
export type assertEqual<t, u> = equals<t, u> extends true ? t : error<`types were not equivalent`>;
export type identity<in out t> = (_: t) => t;
export type extend<t, u extends t> = u;
export type subsume<t extends u, u> = u;
export type defined<t> = Exclude<t, undefined>;
export type requireKeys<o, key extends keyof o> = o & {
    [requiredKey in key]-?: o[requiredKey];
};
export type optionalizeKeys<o, key extends keyof o> = Omit<o, key> & {
    [requiredKey in key]?: o[requiredKey];
};
export type requiredKeyOf<o> = {
    [k in keyof o]-?: o extends {
        [_ in k]-?: o[k];
    } ? k : never;
}[keyof o];
export type optionalKeyOf<o> = Exclude<keyof o, requiredKeyOf<o>>;
/** Type equivalent of ?? */
export type coalesce<t, fallback> = t extends {} ? t : fallback;
export type error<message extends string = string> = `!${message}`;
export type castOnError<t, to> = isTopType<t> extends true ? t : t extends never ? t : t extends error ? to : t;
export type tryCatch<t, onValid> = isAny<t> extends true ? onValid : t extends never ? onValid : t extends error ? t : onValid;
export type RegexLiteral<expression extends string = string> = `/${expression}/`;
export type autocomplete<suggestions extends string> = suggestions | (string & {});
export type tailOf<t extends List> = t extends readonly [unknown, ...infer tail] ? tail : [];
export type headOf<t extends List> = t extends readonly [
    infer head,
    ...unknown[]
] ? head : never;
export type tailOfString<S extends string> = S extends `${string}${infer Tail}` ? Tail : "";
export type headOfString<S extends string> = S extends `${infer Head}${string}` ? Head : "";
export type parametersOf<f> = f extends (...args: infer parameters) => unknown ? parameters : never;
export type returnOf<f> = f extends (...args: never[]) => infer returns ? returns : never;
export type Dict<k extends string = string, v = unknown> = {
    readonly [_ in k]: v;
};
export type List<t = unknown> = readonly t[];
export type arraySubclassToReadonly<t extends unknown[]> = readonly t[number][] & {
    [k in Exclude<keyof t, keyof unknown[]>]: t[k];
};
export type HomogenousTuple<item, length extends number, result extends item[] = []> = result["length"] extends length ? result : HomogenousTuple<item, length, [...result, item]>;
export declare const listFrom: <t>(data: t) => t extends List<unknown> ? t : readonly t[];
export type CollapsibleList<t> = t | readonly t[];
/** Either:
 * A, with all properties of B undefined
 * OR
 * B, with all properties of A undefined
 **/
export type xor<a, b> = evaluate<a & {
    [k in keyof b]?: undefined;
}> | evaluate<b & {
    [k in keyof a]?: undefined;
}>;
export {};
