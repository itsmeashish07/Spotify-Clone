import type { Morph } from "../parse/ast/morph.js";
import type { TypeConfig } from "../scopes/type.js";
import type { Domain } from "../utils/domains.js";
import type { CollapsibleList, Dict } from "../utils/generics.js";
import type { IntersectionState, Intersector } from "./compose.js";
import type { FlattenContext } from "./node.js";
import type { PredicateComparison } from "./predicate.js";
import type { Rules } from "./rules/rules.js";
export type Branch<domain extends Domain = Domain, $ = Dict> = Rules<domain, $> | MetaBranch<domain, $>;
export type MetaBranch<domain extends Domain = Domain, $ = Dict> = {
    rules: Rules<domain, $>;
    morph?: CollapsibleList<Morph>;
    config?: TypeConfig;
};
export type Branches = readonly Branch[];
export type MorphEntry = ["morph", Morph];
export declare const isBranchComparison: (comparison: PredicateComparison) => comparison is BranchesComparison;
export type BranchesComparison = {
    lBranches: Branches;
    rBranches: Branches;
    lExtendsR: number[];
    rExtendsL: number[];
    equalities: [lIndex: number, rIndex: number][];
    distinctIntersections: Branches;
};
export declare const compareBranches: (lConditions: Branches, rConditions: Branches, state: IntersectionState) => BranchesComparison;
export declare const isTransformationBranch: (branch: Branch) => branch is MetaBranch<Domain, Dict>;
export declare const flattenBranch: (branch: Branch, ctx: FlattenContext) => import("./node.js").TraversalEntry[];
export declare const branchIntersection: Intersector<Branch>;
