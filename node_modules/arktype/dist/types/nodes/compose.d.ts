import type { Type } from "../scopes/type.js";
import type { Domain } from "../utils/domains.js";
import type { constructor, Dict, extend } from "../utils/generics.js";
import type { DefaultObjectKind } from "../utils/objectKinds.js";
import { Path } from "../utils/paths.js";
import type { Branches } from "./branch.js";
import type { Range } from "./rules/range.js";
import type { LiteralRules, NarrowableRules } from "./rules/rules.js";
export type Intersector<t> = (l: t, r: t, state: IntersectionState) => IntersectionResult<t>;
type allowUndefinedOperands<f extends Intersector<any>> = f extends Intersector<infer operand> ? Intersector<operand | undefined> : never;
export declare const composeIntersection: <t, reducer extends Intersector<t> = Intersector<t>>(reducer: reducer) => allowUndefinedOperands<reducer>;
export declare const undefinedOperandsMessage = "Unexpected operation two undefined operands";
export type IntersectionResult<t> = t | Empty | Equal;
export type DisjointKinds = extend<Record<string, {
    l: unknown;
    r: unknown;
}>, {
    domain: {
        l: Domain[];
        r: Domain[];
    };
    range: {
        l: Range;
        r: Range;
    };
    tupleLength: {
        l: number;
        r: number;
    };
    class: {
        l: DefaultObjectKind | constructor;
        r: DefaultObjectKind | constructor;
    };
    value: {
        l: unknown;
        r: unknown;
    };
    leftAssignability: {
        l: LiteralRules;
        r: NarrowableRules;
    };
    rightAssignability: {
        l: NarrowableRules;
        r: LiteralRules;
    };
    union: {
        l: Branches;
        r: Branches;
    };
}>;
export declare const disjointDescriptionWriters: {
    domain: ({ l, r }: DisjointContext<"domain">) => string;
    range: ({ l, r }: DisjointContext<"range">) => string;
    class: ({ l, r }: DisjointContext<"class">) => string;
    tupleLength: ({ l, r }: DisjointContext<"tupleLength">) => string;
    value: ({ l, r }: DisjointContext<"value">) => string;
    leftAssignability: ({ l, r }: DisjointContext<"leftAssignability">) => string;
    rightAssignability: ({ l, r }: DisjointContext<"rightAssignability">) => string;
    union: ({ l, r }: DisjointContext<"union">) => string;
};
export declare const stringifyRange: (range: Range) => string;
export type DisjointKind = keyof DisjointKinds;
export declare class IntersectionState {
    #private;
    type: Type;
    lastOperator: "|" | "&";
    path: Path;
    lOptional: boolean;
    rOptional: boolean;
    domain: Domain | undefined;
    constructor(type: Type, lastOperator: "|" | "&");
    get disjoints(): Readonly<DisjointsByPath>;
    addDisjoint<kind extends DisjointKind>(kind: kind, l: DisjointKinds[kind]["l"], r: DisjointKinds[kind]["r"]): Empty;
}
export type DisjointsByPath = Record<string, DisjointContext>;
export type DisjointContext<kind extends DisjointKind = DisjointKind> = {
    kind: kind;
    lOptional: boolean;
    rOptional: boolean;
} & DisjointKinds[kind];
declare const empty: unique symbol;
export type Empty = typeof empty;
export declare const anonymousDisjoint: () => Empty;
export declare const isDisjoint: (result: unknown) => result is typeof empty;
declare const equal: unique symbol;
export type Equal = typeof equal;
export declare const equality: () => Equal;
export declare const isEquality: (result: unknown) => result is typeof equal;
export type IntersectionReducerMap<root extends Dict> = {
    [k in keyof root]-?: Intersector<root[k]>;
};
export type KeyIntersectionFn<root extends Dict> = <key extends keyof root>(key: key, l: root[key], r: root[key], state: IntersectionState) => IntersectionResult<root[key]>;
export type IntersectionReducer<root extends Dict> = KeyIntersectionFn<root> | IntersectionReducerMap<root>;
export type KeyedOperationConfig = {
    onEmpty: "omit" | "bubble";
};
export declare const composeKeyedIntersection: <root extends Dict>(reducer: IntersectionReducer<root>, config: KeyedOperationConfig) => Intersector<root>;
export {};
