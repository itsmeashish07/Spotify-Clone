import type { Narrow } from "../../parse/ast/narrow.js";
import type { Domain, inferDomain } from "../../utils/domains.js";
import type { CollapsibleList, constructor, Dict } from "../../utils/generics.js";
import type { IntersectionState, Intersector } from "../compose.js";
import type { FlattenContext, TraversalEntry, TraversalKey } from "../node.js";
import type { DistilledPropsEntry, PropEntry, PropsRule, StrictPropsEntry } from "./props.js";
import type { FlatBound, Range } from "./range.js";
export type NarrowableRules<$ = Dict> = {
    readonly regex?: CollapsibleList<string>;
    readonly divisor?: number;
    readonly range?: Range;
    readonly props?: PropsRule<$>;
    readonly class?: constructor;
    readonly narrow?: NarrowRule;
};
export type LiteralRules<domain extends Domain = Domain, value extends inferDomain<domain> = inferDomain<domain>> = {
    readonly value: value;
};
export type NarrowRule = CollapsibleList<Narrow>;
export type FlatRules = RuleEntry[];
export type RuleEntry = ["regex", string] | ["divisor", number] | ["bound", FlatBound] | ["class", constructor] | DistilledPropsEntry | StrictPropsEntry | PropEntry | ["narrow", Narrow] | ["value", unknown];
export type Rules<domain extends Domain = Domain, $ = Dict> = Domain extends domain ? NarrowableRules | LiteralRules : domain extends "object" ? defineRuleSet<domain, "props" | "range" | "narrow" | "class", $> : domain extends "string" ? defineRuleSet<domain, "regex" | "range" | "narrow", $> : domain extends "number" ? defineRuleSet<domain, "divisor" | "range" | "narrow", $> : defineRuleSet<domain, "narrow", $>;
type defineRuleSet<domain extends Domain, keys extends keyof NarrowableRules, $> = Pick<NarrowableRules<$>, keys> | LiteralRules<domain>;
export declare const rulesIntersection: Intersector<Rules>;
export declare const narrowableRulesIntersection: Intersector<NarrowableRules<Dict>>;
export declare const flattenRules: (rules: UnknownRules, ctx: FlattenContext) => TraversalEntry[];
export type FlattenAndPushRule<t> = (entries: RuleEntry[], rule: t, ctx: FlattenContext) => void;
type UnknownRules = NarrowableRules & Partial<LiteralRules>;
export declare const precedenceMap: {
    readonly [k in TraversalKey]: number;
};
export declare const literalSatisfiesRules: (data: unknown, rules: NarrowableRules, state: IntersectionState) => boolean;
export {};
