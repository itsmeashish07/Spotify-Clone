import type { Type } from "../scopes/type.js";
import type { Domain } from "../utils/domains.js";
import type { CollapsibleList, Dict } from "../utils/generics.js";
import type { Branch, BranchesComparison } from "./branch.js";
import type { IntersectionResult, KeyIntersectionFn } from "./compose.js";
import { IntersectionState } from "./compose.js";
import type { FlattenContext, TraversalEntry, TypeNode } from "./node.js";
import type { LiteralRules } from "./rules/rules.js";
/** If scope is provided, we also narrow each predicate to match its domain.
 * Otherwise, we use a base predicate for all types, which is easier to
 * manipulate.*/
export type Predicate<domain extends Domain = Domain, $ = Dict> = string extends keyof $ ? true | CollapsibleList<Branch> : true | CollapsibleList<Branch<domain, $>>;
export type PredicateComparison = IntersectionResult<Predicate> | BranchesComparison;
export declare const comparePredicates: (l: Predicate, r: Predicate, context: IntersectionState) => PredicateComparison;
export declare const predicateIntersection: KeyIntersectionFn<Required<TypeNode>>;
export declare const predicateUnion: (domain: Domain, l: Predicate, r: Predicate, type: Type) => true | import("./rules/rules.js").NarrowableRules<Dict> | LiteralRules<Domain, unknown> | import("./branch.js").MetaBranch<Domain, Dict> | readonly Branch[];
export declare const flattenPredicate: (predicate: Predicate, context: FlattenContext) => TraversalEntry[];
export declare const isLiteralCondition: (predicate: Predicate) => predicate is LiteralRules;
