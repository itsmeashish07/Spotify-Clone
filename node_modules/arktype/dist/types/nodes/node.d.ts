import type { ParseContext } from "../parse/definition.js";
import type { Type, TypeConfig } from "../scopes/type.js";
import type { Domain, inferDomain } from "../utils/domains.js";
import type { defined, Dict, entryOf, stringKeyOf } from "../utils/generics.js";
import type { MorphEntry } from "./branch.js";
import type { Intersector } from "./compose.js";
import type { DiscriminatedSwitch } from "./discriminate.js";
import type { Predicate } from "./predicate.js";
import type { LiteralRules, RuleEntry } from "./rules/rules.js";
export type Node<$ = Dict> = Identifier<$> | ResolvedNode<$>;
export type Identifier<$ = Dict> = stringKeyOf<$>;
/**
 * @operator {@link ResolvedNode | node}
 * @docgenTable
 * @tuple ["node", nodeDefinition]
 * @helper type.from(nodeDefinition)
 */
export type ResolvedNode<$ = Dict> = TypeNode<$> | ConfigNode<$>;
export type ConfigNode<$ = Dict> = {
    config: TypeConfig;
    node: TypeNode<$>;
};
export declare const isConfigNode: (node: ResolvedNode) => node is ConfigNode<Dict>;
export type TypeNode<$ = Dict> = {
    readonly [domain in Domain]?: Predicate<domain, $>;
};
export declare const nodeIntersection: Intersector<Node>;
export declare const rootIntersection: (l: Node, r: Node, type: Type) => Node;
export declare const rootUnion: (l: Node, r: Node, type: Type) => ResolvedNode;
export type TraversalNode = Domain | TraversalEntry[];
export type TraversalKey = TraversalEntry[0];
export type TraversalValue<k extends TraversalKey> = Extract<TraversalEntry, [
    k,
    unknown
]>[1];
export type TraversalEntry = RuleEntry | DomainsEntry | MorphEntry | AliasEntry | DomainEntry | BranchesEntry | SwitchEntry | TraversalConfigEntry;
export type AliasEntry = ["alias", string];
export type ConfigEntry = entryOf<TypeConfig>;
export type TraversalConfigEntry = [
    "config",
    {
        config: ConfigEntry[];
        node: TraversalNode;
    }
];
export type DomainEntry = ["domain", Domain];
export type DomainsEntry = [
    "domains",
    {
        readonly [domain in Domain]?: TraversalEntry[];
    }
];
export type BranchesEntry = ["branches", TraversalEntry[][]];
export type SwitchEntry = ["switch", DiscriminatedSwitch];
export type FlattenContext = ParseContext & {
    lastDomain: Domain;
};
export declare const flattenType: (type: Type) => TraversalNode;
export declare const flattenNode: (node: Node, ctx: FlattenContext) => TraversalNode;
export declare const flattenTypeNode: (node: TypeNode, ctx: FlattenContext) => TraversalNode;
export type LiteralNode<domain extends Domain = Domain, value extends inferDomain<domain> = inferDomain<domain>> = {
    [k in domain]: LiteralRules<domain, value>;
};
export declare const isLiteralNode: <domain extends Domain>(node: ResolvedNode, domain: domain) => node is LiteralNode<domain, inferDomain<domain>>;
export type DomainSubtypeResolution<domain extends Domain> = {
    readonly [k in domain]: defined<TypeNode[domain]>;
};
export declare const resolutionExtendsDomain: <domain extends Domain>(resolution: ResolvedNode, domain: domain) => resolution is DomainSubtypeResolution<domain>;
export declare const toArrayNode: (node: Node) => ResolvedNode;
