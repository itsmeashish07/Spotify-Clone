import type { error } from "../../../../utils/generics.js";
import type { BigintLiteral, NumberLiteral } from "../../../../utils/numericLiterals.js";
import type { DynamicState } from "../../reduce/dynamic.js";
import type { state, StaticState } from "../../reduce/static.js";
import type { Scanner } from "../scanner.js";
export declare const parseUnenclosed: (s: DynamicState) => void;
export type parseUnenclosed<s extends StaticState, $> = Scanner.shiftUntilNextTerminator<s["unscanned"]> extends Scanner.shiftResult<infer scanned, infer nextUnscanned> ? tryResolve<s, scanned, $> extends infer result ? result extends error<infer message> ? error<message> : state.setRoot<s, result, nextUnscanned> : never : never;
type tryResolve<s extends StaticState, token extends string, $> = token extends keyof $ ? token : token extends NumberLiteral ? token : token extends BigintLiteral ? token : possibleCompletions<s, token, $>;
export type possibleCompletions<s extends StaticState, token extends string, $> = Extract<keyof $, `${token}${string}`> extends never ? error<writeUnresolvableMessage<token>> : error<`${s["scanned"]}${Extract<keyof $, `${token}${string}`>}`>;
export declare const writeUnresolvableMessage: <token extends string>(token: token) => `'${token}' is unresolvable`;
type writeUnresolvableMessage<token extends string> = `'${token}' is unresolvable`;
export declare const writeMissingOperandMessage: <s extends DynamicState>(s: s) => string;
export type writeMissingOperandMessage<s extends StaticState, operator extends Scanner.InfixToken | undefined = state.previousOperator<s>> = operator extends {} ? writeMissingRightOperandMessage<operator, s["unscanned"]> : writeExpressionExpectedMessage<s["unscanned"]>;
export type writeMissingRightOperandMessage<token extends Scanner.InfixToken, unscanned extends string> = `Token '${token}' requires a right operand${unscanned extends "" ? "" : ` before '${unscanned}'`}`;
export declare const writeMissingRightOperandMessage: <token extends Scanner.InfixToken, unscanned extends string>(token: token, unscanned: unscanned) => `Token '${token}' requires a right operand${unscanned extends "" ? "" : ` before '${unscanned}'`}`;
export declare const writeExpressionExpectedMessage: <unscanned extends string>(unscanned: unscanned) => string;
export type writeExpressionExpectedMessage<unscanned extends string> = `Expected an expression${unscanned extends "" ? "" : ` before '${unscanned}'`}`;
export {};
