import type { Dict } from "../../../utils/generics.js";
export declare class Scanner<Lookahead extends string = string> {
    private chars;
    private i;
    finalized: boolean;
    constructor(def: string);
    /** Get lookahead and advance scanner by one */
    shift(): Lookahead;
    get lookahead(): Lookahead;
    shiftUntil(condition: Scanner.UntilCondition): string;
    shiftUntilNextTerminator(): string;
    get unscanned(): string;
    lookaheadIs<Char extends Lookahead>(char: Char): this is Scanner<Char>;
    lookaheadIsIn<Tokens extends Dict>(tokens: Tokens): this is Scanner<Extract<keyof Tokens, string>>;
}
export declare namespace Scanner {
    type UntilCondition = (scanner: Scanner, shifted: string) => boolean;
    type OnInputEndFn = (scanner: Scanner, shifted: string) => string;
    type ShiftUntilOptions = {
        onInputEnd?: OnInputEndFn;
    };
    const lookaheadIsTerminator: UntilCondition;
    const lookaheadIsNotWhitespace: UntilCondition;
    const comparatorStartChars: {
        readonly "<": true;
        readonly ">": true;
        readonly "=": true;
    };
    const terminatingChars: {
        readonly "|": true;
        readonly "&": true;
        readonly ")": true;
        readonly "[": true;
        readonly "%": true;
        readonly " ": true;
        readonly "<": true;
        readonly ">": true;
        readonly "=": true;
    };
    type TerminatingChar = keyof typeof Scanner.terminatingChars;
    const comparators: {
        readonly "<": true;
        readonly ">": true;
        readonly "<=": true;
        readonly ">=": true;
        readonly "==": true;
    };
    type Comparator = keyof typeof comparators;
    type ComparatorStartChar = keyof typeof comparatorStartChars;
    const oneCharComparators: {
        readonly "<": true;
        readonly ">": true;
    };
    type OneCharComparator = keyof typeof oneCharComparators;
    const comparatorDescriptions: {
        readonly "<": "less than";
        readonly ">": "more than";
        readonly "<=": "at most";
        readonly ">=": "at least";
        readonly "==": "exactly";
    };
    const invertedComparators: {
        readonly "<": ">";
        readonly ">": "<";
        readonly "<=": ">=";
        readonly ">=": "<=";
        readonly "==": "==";
    };
    type InvertedComparators = typeof invertedComparators;
    const branchTokens: {
        readonly "|": true;
        readonly "&": true;
    };
    type BranchToken = keyof typeof branchTokens;
    type InfixToken = BranchToken | Comparator | "%" | ":" | "=>" | "|>";
    type PostfixToken = "[]";
    type OperatorToken = InfixToken | PostfixToken;
    const escapeToken = "\\";
    type EscapeToken = typeof escapeToken;
    const whiteSpaceToken = " ";
    type WhiteSpaceToken = typeof whiteSpaceToken;
    type finalized = "{done}";
    type shift<Lookahead extends string, Unscanned extends string> = `${Lookahead}${Unscanned}`;
    type shiftUntil<unscanned extends string, terminator extends string, scanned extends string = ""> = unscanned extends Scanner.shift<infer lookahead, infer nextUnscanned> ? lookahead extends terminator ? scanned extends `${infer base}${EscapeToken}` ? shiftUntil<nextUnscanned, terminator, `${base}${lookahead}`> : [scanned, unscanned] : shiftUntil<nextUnscanned, terminator, `${scanned}${lookahead}`> : [scanned, ""];
    type shiftUntilNot<unscanned extends string, nonTerminator extends string, scanned extends string = ""> = unscanned extends Scanner.shift<infer lookahead, infer nextUnscanned> ? lookahead extends nonTerminator ? shiftUntilNot<nextUnscanned, nonTerminator, `${scanned}${lookahead}`> : [scanned, unscanned] : [scanned, ""];
    type shiftUntilNextTerminator<unscanned extends string> = shiftUntil<skipWhitespace<unscanned>, TerminatingChar>;
    type skipWhitespace<unscanned extends string> = shiftUntilNot<unscanned, WhiteSpaceToken>[1];
    type shiftResult<scanned extends string, unscanned extends string> = [scanned, unscanned];
}
