import type { MaxComparator, Range } from "../../../../nodes/rules/range.js";
import type { error } from "../../../../utils/generics.js";
import type { NumberLiteral } from "../../../../utils/numericLiterals.js";
import { tryParseWellFormedNumber } from "../../../../utils/numericLiterals.js";
import type { DynamicState } from "../../reduce/dynamic.js";
import { writeUnpairableComparatorMessage } from "../../reduce/shared.js";
import type { state, StaticState } from "../../reduce/static.js";
import { Scanner } from "../scanner.js";
export declare const parseBound: (s: DynamicState, start: Scanner.ComparatorStartChar) => void;
export type parseBound<s extends StaticState, start extends Scanner.ComparatorStartChar, unscanned extends string> = shiftComparator<start, unscanned> extends infer shiftResultOrError ? shiftResultOrError extends Scanner.shiftResult<infer comparator extends Scanner.Comparator, infer nextUnscanned> ? s["root"] extends NumberLiteral ? state.reduceLeftBound<s, s["root"], comparator, nextUnscanned> : parseRightBound<s, comparator, nextUnscanned> : shiftResultOrError : never;
declare const shiftComparator: (s: DynamicState, start: Scanner.ComparatorStartChar) => Scanner.Comparator;
type shiftComparator<start extends Scanner.ComparatorStartChar, unscanned extends string> = unscanned extends `=${infer nextUnscanned}` ? [`${start}=`, nextUnscanned] : start extends Scanner.OneCharComparator ? [start, unscanned] : error<singleEqualsMessage>;
export declare const singleEqualsMessage = "= is not a valid comparator. Use == to check for equality";
type singleEqualsMessage = typeof singleEqualsMessage;
export declare const parseRightBound: (s: DynamicState, comparator: Scanner.Comparator) => void;
export type parseRightBound<s extends StaticState, comparator extends Scanner.Comparator, unscanned extends string> = Scanner.shiftUntilNextTerminator<unscanned> extends Scanner.shiftResult<infer scanned, infer nextUnscanned> ? tryParseWellFormedNumber<scanned, writeInvalidLimitMessage<comparator, scanned>> extends infer limit ? limit extends number ? s["branches"]["range"] extends {} ? comparator extends MaxComparator ? state.reduceRange<s, s["branches"]["range"]["limit"], s["branches"]["range"]["comparator"], comparator, `${limit}`, nextUnscanned> : error<writeUnpairableComparatorMessage<comparator>> : state.reduceSingleBound<s, comparator, `${limit}`, nextUnscanned> : error<limit & string> : never : never;
export declare const writeInvalidLimitMessage: <comparator extends ">" | "<" | ">=" | "<=" | "==", limit extends string>(comparator: comparator, limit: limit) => `Comparator ${comparator} must be followed by a number literal (was '${limit}')`;
export type writeInvalidLimitMessage<comparator extends Scanner.Comparator, limit extends string> = `Comparator ${comparator} must be followed by a number literal (was '${limit}')`;
export declare const writeEmptyRangeMessage: (range: Range) => string;
export type BoundableDomain = "string" | "number" | "object";
export {};
