import type { error } from "../../utils/generics.js";
import type { inferAst } from "../ast/ast.js";
import type { ParseContext } from "../definition.js";
import { DynamicState } from "./reduce/dynamic.js";
import type { state, StaticState } from "./reduce/static.js";
import { parseOperand } from "./shift/operand/operand.js";
import { parseOperator } from "./shift/operator/operator.js";
import type { Scanner } from "./shift/scanner.js";
export declare const parseString: (def: string, ctx: ParseContext) => import("../../nodes/node.js").Node;
export type parseString<def extends string, $> = maybeNaiveParse<def, $>;
export type inferString<def extends string, $> = inferAst<parseString<def, $>, $>;
/**
 * Try to parse the definition from right to left using the most common syntax.
 * This can be much more efficient for simple definitions.
 */
type maybeNaiveParse<def extends string, $> = def extends `${infer child}[]` ? child extends keyof $ ? [child, "[]"] : fullStringParse<def, $> : def extends keyof $ ? def : fullStringParse<def, $>;
export declare const maybeNaiveParse: (def: string, ctx: ParseContext) => string | import("../../nodes/node.js").ResolvedNode<import("../../utils/generics.js").Dict> | undefined;
export declare const fullStringParse: (def: string, ctx: ParseContext) => import("../../nodes/node.js").Node;
type fullStringParse<def extends string, $> = loop<state.initialize<def>, $>;
declare const loop: (s: DynamicState) => import("../../nodes/node.js").Node;
type loop<s extends StaticState | error, $> = s extends StaticState ? loopValid<s, $> : s;
type loopValid<s extends StaticState, $> = s["unscanned"] extends Scanner.finalized ? s["root"] : loop<next<s, $>, $>;
declare const next: (s: DynamicState) => void;
type next<s extends StaticState, $> = s["root"] extends undefined ? parseOperand<s, $> : parseOperator<s>;
export {};
