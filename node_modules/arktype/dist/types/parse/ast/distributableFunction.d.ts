import type { TypeNode } from "../../nodes/node.js";
import type { NarrowableRules } from "../../nodes/rules/rules.js";
import type { Domain, domainOf, inferDomain } from "../../utils/domains.js";
import type { evaluate } from "../../utils/generics.js";
import type { ParseContext } from "../definition.js";
export type DistributableFunction<input = any, args extends any[] = any[], output = unknown> = (input: input, ...args: args) => output;
export type distributable<f extends DistributableFunction> = f | distributeFunction<f>;
export type distributeFunction<f extends DistributableFunction> = f extends DistributableFunction<infer input, infer args, infer output> ? evaluate<{
    [domain in domainOf<input>]?: (input: unknown extends input ? unknown : Extract<input, inferDomain<domain>>, ...args: args) => output;
}> : never;
export declare const writeMalformedDistributableFunctionMessage: (def: unknown) => string;
export type DistributedFunctionNode<f, ruleKey extends keyof NarrowableRules> = {
    [domain in Domain]?: FunctionInDomain<f, ruleKey>;
};
export type FunctionInDomain<f, ruleKey extends keyof NarrowableRules> = {
    [k in ruleKey]: f;
};
export declare const distributeFunctionToNode: <f extends DistributableFunction<any, any[], unknown>, ruleKey extends keyof NarrowableRules>(distributableFunction: distributable<f>, node: TypeNode, ctx: ParseContext, ruleKey: ruleKey) => DistributedFunctionNode<f, ruleKey>;
