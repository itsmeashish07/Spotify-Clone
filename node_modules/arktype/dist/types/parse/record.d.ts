import type { ResolvedNode } from "../nodes/node.js";
import type { Dict, evaluate } from "../utils/generics.js";
import type { inferDefinition, ParseContext } from "./definition.js";
import { Scanner } from "./string/shift/scanner.js";
export declare const parseRecord: (def: Dict, ctx: ParseContext) => ResolvedNode;
type withPossiblePreviousEscapeCharacter<k> = k extends `${infer name}?` ? `${name}${Scanner.EscapeToken}?` : k;
export type inferRecord<def extends Dict, $> = evaluate<{
    [k in keyof def as k extends requiredKeyOf<def> ? k : never]: inferDefinition<def[withPossiblePreviousEscapeCharacter<k>], $>;
} & {
    [k in Exclude<requiredKeyOf<def>, keyof def>]: inferDefinition<def[withPossiblePreviousEscapeCharacter<k>], $>;
} & {
    [optionalKeyName in optionalKeyOf<def>]?: inferDefinition<def[`${optionalKeyName}?`], $>;
}>;
type KeyParseResult<name extends string, isOptional extends boolean> = [
    name,
    isOptional
];
type parseKey<k> = k extends optionalKeyWithName<infer name> ? name extends `${infer baseName}${Scanner.EscapeToken}` ? [`${baseName}?`, false] : [name, true] : [k, false];
type optionalKeyWithName<name extends string = string> = `${name}?`;
type optionalKeyOf<def> = {
    [k in keyof def]: parseKey<k> extends KeyParseResult<infer name, true> ? name : never;
}[keyof def] & unknown;
type requiredKeyOf<def> = {
    [k in keyof def]: parseKey<k> extends KeyParseResult<infer name, false> ? name : never;
}[keyof def] & unknown;
export {};
