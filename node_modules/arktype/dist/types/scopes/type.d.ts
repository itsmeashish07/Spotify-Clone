import type { Node, TraversalNode } from "../nodes/node.js";
import type { ParsedMorph } from "../parse/ast/morph.js";
import type { as, inferDefinition, validateDefinition } from "../parse/definition.js";
import type { ProblemOptions } from "../traverse/problems.js";
import type { CheckResult } from "../traverse/traverse.js";
import type { defer, evaluate } from "../utils/generics.js";
import type { BuiltinClass } from "../utils/objectKinds.js";
import type { Expressions } from "./expressions.js";
import type { Scope } from "./scope.js";
export type TypeParser<$> = {
    <def>(def: validateDefinition<def, $>): parseType<def, $>;
    <def>(def: validateDefinition<def, $>, opts: TypeOptions): parseType<def, $>;
} & TypeParserProps<$>;
export type TypeParserProps<$> = {
    from: Expressions<$>["node"];
};
export type parseType<def, $> = [def] extends [validateDefinition<def, $>] ? Type<inferDefinition<def, $>> : Type<never>;
type TypeRoot<t = unknown> = evaluate<{
    [as]: t;
    infer: asOut<t>;
    inferIn: asIn<t>;
    allows: (data: unknown) => data is asIn<t>;
    assert: (data: unknown) => asOut<t>;
    node: Node;
    flat: TraversalNode;
    qualifiedName: QualifiedTypeName;
    definition: unknown;
    scope: Scope;
    includesMorph: boolean;
    config: TypeConfig;
}>;
export type KeyCheckKind = "loose" | "strict" | "distilled";
export type TypeOptions = evaluate<{
    keys?: KeyCheckKind;
} & ProblemOptions>;
export type TypeConfig = TypeOptions;
export declare const initializeType: (name: string, definition: unknown, config: TypeConfig, scope: Scope) => ((data: unknown) => CheckResult<unknown>) & {
    infer: unknown;
    inferIn: unknown;
    allows: (data: unknown) => data is unknown;
    assert: (data: unknown) => unknown;
    node: Node;
    flat: TraversalNode;
    qualifiedName: QualifiedTypeName;
    definition: unknown;
    scope: Scope;
    includesMorph: boolean;
    config: {
        keys?: KeyCheckKind;
        mustBe?: import("../traverse/problems.js").MustBeWriter<import("../traverse/problems.js").ProblemCode>;
        writeReason?: import("../traverse/problems.js").ReasonWriter<import("../traverse/problems.js").ProblemCode>;
        addContext?: import("../traverse/problems.js").ContextWriter;
    };
    [as]: unknown;
};
export declare const isType: (value: unknown) => value is Type<unknown>;
export type Type<t = unknown> = defer<Checker<t> & TypeRoot<t>>;
export type Checker<t> = (data: unknown) => CheckResult<asOut<t>>;
export type QualifiedTypeName = `${string}.${string}`;
export type AnonymousTypeName = `Î»${string}`;
export declare const isAnonymousName: (name: string) => name is `\u03BB${string}`;
export type asIn<t> = [t, asIo<t, "out">] extends [asIo<t, "out">, t] ? t : asIo<t, "in">;
export type asOut<t> = [t, asIo<t, "out">] extends [asIo<t, "out">, t] ? t : asIo<t, "out">;
type asIo<t, io extends "in" | "out"> = t extends ParsedMorph<infer i, infer o> ? io extends "in" ? i : o : t extends object ? t extends BuiltinClass | ((...args: any[]) => any) ? t : {
    [k in keyof t]: asIo<t[k], io>;
} : t;
export {};
