import type { FlatBound } from "../nodes/rules/range.js";
import { DataWrapper } from "../utils/data.js";
import type { Domain } from "../utils/domains.js";
import type { arraySubclassToReadonly, constructor, evaluate, RegexLiteral } from "../utils/generics.js";
import type { DefaultObjectKind } from "../utils/objectKinds.js";
import { Path } from "../utils/paths.js";
import type { ConstrainedRuleTraversalData, TraversalState } from "./traverse.js";
export declare class ArkTypeError extends TypeError {
    cause: Problems;
    constructor(problems: Problems);
}
export declare class Problem<code extends ProblemCode = ProblemCode> {
    code: code;
    path: Path;
    private data;
    private source;
    private writers;
    parts?: Problem[];
    constructor(code: code, path: Path, data: ProblemData<code>, source: ProblemSource<code>, writers: ProblemWriters<code>);
    toString(): string;
    get message(): string;
    get reason(): string;
    get mustBe(): string;
}
export type AddProblemOptions<data = unknown> = {
    data?: data;
    path?: string[];
};
declare class ProblemArray extends Array<Problem> {
    #private;
    byPath: Record<string, Problem>;
    count: number;
    constructor(state: TraversalState);
    mustBe(description: string, opts?: AddProblemOptions): Problem<ProblemCode>;
    add<code extends ProblemCode>(code: code, source: ProblemSource<code>, opts?: AddProblemOptions<ProblemData<code>>): Problem;
    addProblem(problem: Problem): void;
    get summary(): string;
    toString(): string;
    throw(): never;
}
export declare const Problems: new (state: TraversalState) => Problems;
export type Problems = arraySubclassToReadonly<ProblemArray>;
export declare const domainsToDescriptions: (domains: Domain[]) => ("boolean" | "undefined" | "null" | "a bigint" | "a number" | "an object" | "a string" | "a symbol")[];
export declare const objectKindsToDescriptions: (kinds: DefaultObjectKind[]) => ("an object" | "an array" | "a function" | "a Date" | "a RegExp" | "an Error" | "a Map" | "a Set" | "a String object" | "a Number object" | "a Boolean object" | "a Promise" | "a WeakMap" | "a WeakSet")[];
export declare const describeBranches: (descriptions: string[]) => string;
type ProblemSources = {
    divisor: number;
    class: constructor;
    domain: Domain;
    missing: undefined;
    extraneous: unknown;
    bound: FlatBound;
    regex: RegexLiteral;
    value: unknown;
    multi: Problem[];
    branches: readonly Problem[];
    custom: string;
    cases: string[];
};
export type ProblemCode = evaluate<keyof ProblemSources>;
export type ProblemSource<code extends ProblemCode = ProblemCode> = ProblemSources[code];
type ProblemDataByCode = {
    [code in ProblemCode]: code extends keyof ConstrainedRuleTraversalData ? ConstrainedRuleTraversalData[code] : unknown;
};
export type ProblemData<code extends ProblemCode = ProblemCode> = ProblemDataByCode[code];
export type MustBeWriter<code extends ProblemCode> = string | ((source: ProblemSources[code]) => string);
export type ReasonWriter<code extends ProblemCode = ProblemCode> = (mustBe: string, data: DataWrapper<code extends keyof ConstrainedRuleTraversalData ? ConstrainedRuleTraversalData[code] : unknown>) => string;
export type ContextWriter = (reason: string, path: Path) => string;
export declare const problemCodes: readonly ProblemCode[];
export declare const defaultProblemWriters: ProblemWritersByCode;
export declare const compileProblemWriters: (input: ProblemsConfig | undefined) => ProblemWritersByCode;
export type ProblemOptions<code extends ProblemCode = ProblemCode> = {
    mustBe?: MustBeWriter<code>;
    writeReason?: ReasonWriter<code>;
    addContext?: ContextWriter;
};
export type ProblemsConfig = evaluate<{
    writeReason?: ReasonWriter;
    addContext?: ContextWriter;
} & ProblemsConfigByCode>;
export type ProblemsConfigByCode = {
    [code in ProblemCode]?: ProblemOptions<code>;
};
export type ProblemWritersByCode = {
    [code in ProblemCode]: ProblemWriters<code>;
};
export type ProblemWriters<code extends ProblemCode = ProblemCode> = Required<ProblemOptions<code>>;
export {};
