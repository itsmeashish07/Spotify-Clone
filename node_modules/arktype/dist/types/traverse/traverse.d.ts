import type { ConfigEntry, TraversalEntry, TraversalKey, TraversalNode, TraversalValue } from "../nodes/node.js";
import type { TraversalProp } from "../nodes/rules/props.js";
import type { Scope } from "../scopes/scope.js";
import type { Type, TypeConfig } from "../scopes/type.js";
import type { SizedData } from "../utils/data.js";
import type { extend, stringKeyOf, xor } from "../utils/generics.js";
import { Path } from "../utils/paths.js";
import type { ProblemCode, ProblemWriters } from "./problems.js";
import { Problems } from "./problems.js";
export declare const traverseRoot: (t: Type, data: unknown) => CheckResult<unknown>;
export type CheckResult<out = unknown> = xor<{
    data: out;
}, {
    problems: Problems;
}>;
export declare class TraversalState<data = unknown> {
    #private;
    data: data;
    type: Type;
    path: Path;
    problems: Problems;
    entriesToPrune: [data: Record<string, unknown>, key: string][];
    failFast: boolean;
    traversalConfig: TraversalConfig;
    readonly rootScope: Scope;
    constructor(data: data, type: Type);
    getProblemConfig<code extends ProblemCode>(code: code): ProblemWriters<code>;
    traverseConfig(configEntries: ConfigEntry[], node: TraversalNode): boolean;
    traverseKey(key: stringKeyOf<this["data"]>, node: TraversalNode): boolean;
    traverseResolution(name: string): boolean;
    traverseBranches(branches: TraversalEntry[][]): boolean;
}
export type TraversalConfig = {
    [k in keyof TypeConfig]-?: TypeConfig[k][];
};
export declare const traverse: (node: TraversalNode, state: TraversalState) => boolean;
export declare const checkEntries: (entries: TraversalEntry[], state: TraversalState) => boolean;
export declare const checkRequiredProp: (prop: TraversalProp, state: TraversalState<TraversableData>) => boolean;
export type ValidationTraversalKey = Exclude<TraversalKey, "morph">;
export type EntryChecker<k extends TraversalKey> = (constraint: TraversalValue<k>, state: TraversalState<RuleData<k>>) => boolean;
export type TraversableData = Record<string | number, unknown>;
export type ConstrainedRuleTraversalData = extend<{
    [k in TraversalKey]?: unknown;
}, {
    regex: string;
    divisor: number;
    bound: SizedData;
    prerequisiteProp: TraversableData;
    optionalProp: TraversableData;
    requiredProp: TraversableData;
    indexProp: TraversableData;
    distilledProps: TraversableData;
    strictProps: TraversableData;
}>;
export type RuleData<k extends TraversalKey> = k extends keyof ConstrainedRuleTraversalData ? ConstrainedRuleTraversalData[k] : unknown;
