"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ArkTypeError: ()=>ArkTypeError,
    Problem: ()=>Problem,
    Problems: ()=>Problems,
    domainsToDescriptions: ()=>domainsToDescriptions,
    objectKindsToDescriptions: ()=>objectKindsToDescriptions,
    describeBranches: ()=>describeBranches,
    problemCodes: ()=>problemCodes,
    defaultProblemWriters: ()=>defaultProblemWriters,
    compileProblemWriters: ()=>compileProblemWriters
});
const _scannerJs = require("../parse/string/shift/scanner.js");
const _dataJs = require("../utils/data.js");
const _domainsJs = require("../utils/domains.js");
const _genericsJs = require("../utils/generics.js");
const _numericLiteralsJs = require("../utils/numericLiterals.js");
const _objectKindsJs = require("../utils/objectKinds.js");
const _pathsJs = require("../utils/paths.js");
const _serializeJs = require("../utils/serialize.js");
function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
    return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateFieldInit(obj, privateMap, value) {
    _checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
    _classApplyDescriptorSet(receiver, descriptor, value);
    return value;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class ArkTypeError extends TypeError {
    constructor(problems){
        super(`${problems}`);
        _defineProperty(this, "cause", void 0);
        this.cause = problems;
    }
}
class Problem {
    toString() {
        return this.message;
    }
    get message() {
        return this.writers.addContext(this.reason, this.path);
    }
    get reason() {
        return this.writers.writeReason(this.mustBe, new _dataJs.DataWrapper(this.data));
    }
    get mustBe() {
        return typeof this.writers.mustBe === "string" ? this.writers.mustBe : this.writers.mustBe(this.source);
    }
    constructor(code, path, data, source, writers){
        _defineProperty(this, "code", void 0);
        _defineProperty(this, "path", void 0);
        _defineProperty(this, "data", void 0);
        _defineProperty(this, "source", void 0);
        _defineProperty(this, "writers", void 0);
        _defineProperty(this, "parts", void 0);
        this.code = code;
        this.path = path;
        this.data = data;
        this.source = source;
        this.writers = writers;
        if (this.code === "multi") {
            this.parts = this.source;
        }
    }
}
var _state = /*#__PURE__*/ new WeakMap();
class ProblemArray extends Array {
    mustBe(description, opts) {
        return this.add("custom", description, opts);
    }
    add(code, source, opts) {
        // copy the path to avoid future mutations affecting it
        const path = _pathsJs.Path.from(opts?.path ?? _classPrivateFieldGet(this, _state).path);
        const data = // we have to check for the presence of the key explicitly since the
        // data could be undefined or null
        opts && "data" in opts ? opts.data : _classPrivateFieldGet(this, _state).data;
        const problem = new Problem(// avoid a bunch of errors from TS trying to discriminate the
        // problem input based on the code
        code, path, data, source, _classPrivateFieldGet(this, _state).getProblemConfig(code));
        this.addProblem(problem);
        return problem;
    }
    addProblem(problem) {
        const pathKey = `${problem.path}`;
        const existing = this.byPath[pathKey];
        if (existing) {
            if (existing.parts) {
                existing.parts.push(problem);
            } else {
                const problemIntersection = new Problem("multi", existing.path, existing.data, [
                    existing,
                    problem
                ], _classPrivateFieldGet(this, _state).getProblemConfig("multi"));
                const existingIndex = this.indexOf(existing);
                // If existing is found (which it always should be unless this was externally mutated),
                // replace it with the new problem intersection. In case it isn't for whatever reason,
                // just append the intersection.
                this[existingIndex === -1 ? this.length : existingIndex] = problemIntersection;
                this.byPath[pathKey] = problemIntersection;
            }
        } else {
            this.byPath[pathKey] = problem;
            this.push(problem);
        }
        this.count++;
    }
    get summary() {
        return `${this}`;
    }
    toString() {
        return this.join("\n");
    }
    throw() {
        throw new ArkTypeError(this);
    }
    constructor(state){
        super();
        _defineProperty(this, "byPath", {});
        _defineProperty(this, "count", 0);
        _classPrivateFieldInit(this, _state, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldSet(this, _state, state);
    }
}
const Problems = ProblemArray;
const capitalize = (s)=>s[0].toUpperCase() + s.slice(1);
const domainsToDescriptions = (domains)=>domains.map((objectKind)=>_domainsJs.domainDescriptions[objectKind]);
const objectKindsToDescriptions = (kinds)=>kinds.map((objectKind)=>_objectKindsJs.objectKindDescriptions[objectKind]);
const describeBranches = (descriptions)=>{
    if (descriptions.length === 0) {
        return "never";
    }
    if (descriptions.length === 1) {
        return descriptions[0];
    }
    let description = "";
    for(let i = 0; i < descriptions.length - 1; i++){
        description += descriptions[i];
        if (i < descriptions.length - 2) {
            description += ", ";
        }
    }
    description += ` or ${descriptions[descriptions.length - 1]}`;
    return description;
};
const writeDefaultReason = (mustBe, was)=>`must be ${mustBe}${was && ` (was ${was})`}`;
const addDefaultContext = (reason, path)=>path.length === 0 ? capitalize(reason) : path.length === 1 && (0, _numericLiteralsJs.isWellFormedInteger)(path[0]) ? `Item at index ${path[0]} ${reason}` : `${path} ${reason}`;
const defaultProblemConfig = {
    divisor: {
        mustBe: (divisor)=>divisor === 1 ? `an integer` : `a multiple of ${divisor}`
    },
    class: {
        mustBe: (expected)=>{
            const possibleObjectKind = (0, _objectKindsJs.getExactConstructorObjectKind)(expected);
            return possibleObjectKind ? _objectKindsJs.objectKindDescriptions[possibleObjectKind] : `an instance of ${expected.name}`;
        },
        writeReason: (mustBe, data)=>writeDefaultReason(mustBe, data.className)
    },
    domain: {
        mustBe: (domain)=>_domainsJs.domainDescriptions[domain],
        writeReason: (mustBe, data)=>writeDefaultReason(mustBe, data.domain)
    },
    missing: {
        mustBe: ()=>"defined",
        writeReason: (mustBe)=>writeDefaultReason(mustBe, "")
    },
    extraneous: {
        mustBe: ()=>"removed",
        writeReason: (mustBe)=>writeDefaultReason(mustBe, "")
    },
    bound: {
        mustBe: (bound)=>`${_scannerJs.Scanner.comparatorDescriptions[bound.comparator]} ${bound.limit}${bound.units ? ` ${bound.units}` : ""}`,
        writeReason: (mustBe, data)=>writeDefaultReason(mustBe, `${data.size}`)
    },
    regex: {
        mustBe: (expression)=>`a string matching ${expression}`
    },
    value: {
        mustBe: _serializeJs.stringify
    },
    branches: {
        mustBe: (branchProblems)=>describeBranches(branchProblems.map((problem)=>`${problem.path} must be ${problem.parts ? describeBranches(problem.parts.map((part)=>part.mustBe)) : problem.mustBe}`)),
        writeReason: (mustBe, data)=>`${mustBe} (was ${data})`,
        addContext: (reason, path)=>path.length ? `At ${path}, ${reason}` : reason
    },
    multi: {
        mustBe: (problems)=>"• " + problems.map((_)=>_.mustBe).join("\n• "),
        writeReason: (mustBe, data)=>`${data} must be...\n${mustBe}`,
        addContext: (reason, path)=>path.length ? `At ${path}, ${reason}` : reason
    },
    custom: {
        mustBe: (mustBe)=>mustBe
    },
    cases: {
        mustBe: (cases)=>describeBranches(cases)
    }
};
const problemCodes = (0, _genericsJs.objectKeysOf)(defaultProblemConfig);
const compileDefaultProblemWriters = ()=>{
    const result = {};
    let code;
    for (code of problemCodes){
        result[code] = {
            mustBe: defaultProblemConfig[code].mustBe,
            writeReason: defaultProblemConfig[code].writeReason ?? writeDefaultReason,
            addContext: defaultProblemConfig[code].addContext ?? addDefaultContext
        };
    }
    return result;
};
const defaultProblemWriters = compileDefaultProblemWriters();
const compileProblemWriters = (input)=>{
    if (!input) {
        return defaultProblemWriters;
    }
    const result = {};
    for (const code of problemCodes){
        result[code] = {
            mustBe: input[code]?.mustBe ?? defaultProblemConfig[code].mustBe,
            writeReason: input[code]?.writeReason ?? defaultProblemConfig[code].writeReason ?? input.writeReason ?? writeDefaultReason,
            addContext: input[code]?.addContext ?? defaultProblemConfig[code].addContext ?? input.addContext ?? addDefaultContext
        };
    }
    return result;
};
