"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    parseTuple: ()=>parseTuple,
    writeMalformedFunctionalExpressionMessage: ()=>writeMalformedFunctionalExpressionMessage
});
const _nodeJs = require("../../nodes/node.js");
const _domainsJs = require("../../utils/domains.js");
const _errorsJs = require("../../utils/errors.js");
const _definitionJs = require("../definition.js");
const _unenclosedJs = require("../string/shift/operand/unenclosed.js");
const _configJs = require("./config.js");
const _keyofJs = require("./keyof.js");
const _morphJs = require("./morph.js");
const _narrowJs = require("./narrow.js");
const parseTuple = (def, ctx)=>{
    if (isIndexOneExpression(def)) {
        return indexOneParsers[def[1]](def, ctx);
    }
    if (isIndexZeroExpression(def)) {
        return prefixParsers[def[0]](def, ctx);
    }
    const props = {
        //  length is created as a prerequisite prop, ensuring if it is invalid,
        //  no other props will be checked, which is usually desirable for tuple
        //  definitions.
        length: [
            "!",
            {
                number: {
                    value: def.length
                }
            }
        ]
    };
    for(let i = 0; i < def.length; i++){
        ctx.path.push(`${i}`);
        props[i] = (0, _definitionJs.parseDefinition)(def[i], ctx);
        ctx.path.pop();
    }
    return {
        object: {
            class: Array,
            props
        }
    };
};
const parseBranchTuple = (def, ctx)=>{
    if (def[2] === undefined) {
        return (0, _errorsJs.throwParseError)((0, _unenclosedJs.writeMissingRightOperandMessage)(def[1], ""));
    }
    const l = (0, _definitionJs.parseDefinition)(def[0], ctx);
    const r = (0, _definitionJs.parseDefinition)(def[2], ctx);
    return def[1] === "&" ? (0, _nodeJs.rootIntersection)(l, r, ctx.type) : (0, _nodeJs.rootUnion)(l, r, ctx.type);
};
const parseArrayTuple = (def, scope)=>(0, _nodeJs.toArrayNode)((0, _definitionJs.parseDefinition)(def[0], scope));
const writeMalformedFunctionalExpressionMessage = (operator, rightDef)=>`Expression requires a function following '${operator}' (was ${typeof rightDef})`;
const isIndexOneExpression = (def)=>indexOneParsers[def[1]] !== undefined;
const indexOneParsers = {
    "|": parseBranchTuple,
    "&": parseBranchTuple,
    "[]": parseArrayTuple,
    "=>": _narrowJs.parseNarrowTuple,
    "|>": _morphJs.parseMorphTuple,
    ":": _configJs.parseConfigTuple
};
const prefixParsers = {
    keyof: _keyofJs.parseKeyOfTuple,
    instanceof: (def)=>{
        if (typeof def[1] !== "function") {
            return (0, _errorsJs.throwParseError)(`Expected a constructor following 'instanceof' operator (was ${typeof def[1]}).`);
        }
        return {
            object: {
                class: def[1]
            }
        };
    },
    "===": (def)=>({
            [(0, _domainsJs.domainOf)(def[1])]: {
                value: def[1]
            }
        }),
    node: (def)=>def[1]
};
const isIndexZeroExpression = (def)=>prefixParsers[def[0]] !== undefined;
