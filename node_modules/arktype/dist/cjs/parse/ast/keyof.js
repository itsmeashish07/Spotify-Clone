"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "parseKeyOfTuple", {
    enumerable: true,
    get: ()=>parseKeyOfTuple
});
const _propsJs = require("../../nodes/rules/props.js");
const _errorsJs = require("../../utils/errors.js");
const _freezeJs = require("../../utils/freeze.js");
const _genericsJs = require("../../utils/generics.js");
const _numericLiteralsJs = require("../../utils/numericLiterals.js");
const _objectKindsJs = require("../../utils/objectKinds.js");
const _serializeJs = require("../../utils/serialize.js");
const _definitionJs = require("../definition.js");
const _intersectionJs = require("./intersection.js");
const arrayIndexStringBranch = (0, _freezeJs.deepFreeze)({
    regex: _numericLiteralsJs.wellFormedNonNegativeIntegerMatcher.source
});
const arrayIndexNumberBranch = (0, _freezeJs.deepFreeze)({
    range: {
        min: {
            comparator: ">=",
            limit: 0
        }
    },
    divisor: 1
});
const parseKeyOfTuple = (def, ctx)=>{
    const resolution = ctx.type.scope.resolveNode((0, _definitionJs.parseDefinition)(def[1], ctx));
    const predicateKeys = (0, _genericsJs.objectKeysOf)(resolution).map((domain)=>keysOfPredicate(domain, resolution[domain]));
    const sharedKeys = sharedKeysOf(predicateKeys);
    if (!sharedKeys.length) {
        return (0, _intersectionJs.writeImplicitNeverMessage)(ctx.path, "keyof");
    }
    const keyNode = {};
    for (const key of sharedKeys){
        const keyType = typeof key;
        if (keyType === "string" || keyType === "number" || keyType === "symbol") {
            var _keyNode, _keyType;
            (_keyNode = keyNode)[_keyType = keyType] ?? (_keyNode[_keyType] = []);
            keyNode[keyType].push({
                value: key
            });
        } else if (key === _numericLiteralsJs.wellFormedNonNegativeIntegerMatcher) {
            var _keyNode1, _keyNode2;
            (_keyNode1 = keyNode).string ?? (_keyNode1.string = []);
            keyNode.string.push(arrayIndexStringBranch);
            (_keyNode2 = keyNode).number ?? (_keyNode2.number = []);
            keyNode.number.push(arrayIndexNumberBranch);
        } else {
            return (0, _errorsJs.throwInternalError)(`Unexpected keyof key '${(0, _serializeJs.stringify)(key)}'`);
        }
    }
    return Object.fromEntries(Object.entries(keyNode).map(([domain, branches])=>[
            domain,
            branches.length === 1 ? branches[0] : branches
        ]));
};
const baseKeysByDomain = {
    bigint: (0, _genericsJs.prototypeKeysOf)(0n),
    boolean: (0, _genericsJs.prototypeKeysOf)(false),
    null: [],
    number: (0, _genericsJs.prototypeKeysOf)(0),
    // TS doesn't include the Object prototype in keyof, so keyof object is never
    object: [],
    string: (0, _genericsJs.prototypeKeysOf)(""),
    symbol: (0, _genericsJs.prototypeKeysOf)(Symbol()),
    undefined: []
};
const keysOfPredicate = (domain, predicate)=>domain !== "object" || predicate === true ? baseKeysByDomain[domain] : sharedKeysOf((0, _genericsJs.listFrom)(predicate).map((branch)=>keysOfObjectBranch(branch)));
const sharedKeysOf = (keyBranches)=>{
    if (!keyBranches.length) {
        return [];
    }
    let sharedKeys = keyBranches[0];
    for(let i = 1; i < keyBranches.length; i++){
        // we can filter directly by equality here because the RegExp we're
        // using will always be reference equal to
        // wellFormedNonNegativeIntegerMatcher
        sharedKeys = sharedKeys.filter((k)=>keyBranches[i].includes(k));
    }
    return sharedKeys;
};
const keysOfObjectBranch = (branch)=>{
    const result = [];
    if ("props" in branch) {
        for (const key of Object.keys(branch.props)){
            if (key === _propsJs.mappedKeys.index) {
                // if any number is a valid key push this RegExp
                result.push(_numericLiteralsJs.wellFormedNonNegativeIntegerMatcher);
            } else if (!result.includes(key)) {
                result.push(key);
                if (_numericLiteralsJs.wellFormedNonNegativeIntegerMatcher.test(key)) {
                    // allow numeric access to keys
                    result.push((0, _numericLiteralsJs.tryParseWellFormedInteger)(key, `Unexpectedly failed to parse an integer from key '${key}'`));
                }
            }
        }
    }
    if ("class" in branch) {
        const constructor = typeof branch.class === "string" ? _objectKindsJs.defaultObjectKinds[branch.class] : branch.class;
        for (const key of (0, _genericsJs.prototypeKeysOf)(constructor.prototype)){
            if (!result.includes(key)) {
                result.push(key);
            }
        }
    }
    return result;
};
