"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    parseBound: ()=>parseBound,
    singleEqualsMessage: ()=>singleEqualsMessage,
    parseRightBound: ()=>parseRightBound,
    writeInvalidLimitMessage: ()=>writeInvalidLimitMessage,
    writeEmptyRangeMessage: ()=>writeEmptyRangeMessage
});
const _composeJs = require("../../../../nodes/compose.js");
const _rangeJs = require("../../../../nodes/rules/range.js");
const _errorsJs = require("../../../../utils/errors.js");
const _genericsJs = require("../../../../utils/generics.js");
const _numericLiteralsJs = require("../../../../utils/numericLiterals.js");
const _boundJs = require("../../../ast/bound.js");
const _sharedJs = require("../../reduce/shared.js");
const _scannerJs = require("../scanner.js");
const parseBound = (s, start)=>{
    const comparator = shiftComparator(s, start);
    const maybeMin = s.ejectRootIfLimit();
    return maybeMin === undefined ? parseRightBound(s, comparator) : s.reduceLeftBound(maybeMin, comparator);
};
const shiftComparator = (s, start)=>s.scanner.lookaheadIs("=") ? `${start}${s.scanner.shift()}` : (0, _genericsJs.isKeyOf)(start, _scannerJs.Scanner.oneCharComparators) ? start : s.error(singleEqualsMessage);
const singleEqualsMessage = `= is not a valid comparator. Use == to check for equality`;
const parseRightBound = (s, comparator)=>{
    const limitToken = s.scanner.shiftUntilNextTerminator();
    const limit = (0, _numericLiteralsJs.tryParseWellFormedNumber)(limitToken, writeInvalidLimitMessage(comparator, limitToken + s.scanner.unscanned));
    const openRange = s.ejectRangeIfOpen();
    const rightBound = {
        comparator,
        limit
    };
    const range = openRange ? !hasComparatorIn(rightBound, _rangeJs.maxComparators) ? s.error((0, _sharedJs.writeUnpairableComparatorMessage)(comparator)) : (0, _rangeJs.compareStrictness)("min", openRange, rightBound) === "l" ? s.error(writeEmptyRangeMessage({
        min: openRange,
        max: rightBound
    })) : {
        min: openRange,
        max: rightBound
    } : hasComparator(rightBound, "==") ? rightBound : hasComparatorIn(rightBound, _rangeJs.minComparators) ? {
        min: rightBound
    } : hasComparatorIn(rightBound, _rangeJs.maxComparators) ? {
        max: rightBound
    } : (0, _errorsJs.throwInternalError)(`Unexpected comparator '${rightBound.comparator}'`);
    s.intersect(distributeRange(range, s));
};
const distributeRange = (range, s)=>{
    const resolution = s.resolveRoot();
    const domains = (0, _genericsJs.objectKeysOf)(resolution);
    const distributedRange = {};
    const rangePredicate = {
        range
    };
    const isBoundable = domains.every((domain)=>{
        switch(domain){
            case "string":
                distributedRange.string = rangePredicate;
                return true;
            case "number":
                distributedRange.number = rangePredicate;
                return true;
            case "object":
                distributedRange.object = rangePredicate;
                if (resolution.object === true) {
                    return false;
                }
                return (0, _genericsJs.listFrom)(resolution.object).every((branch)=>"class" in branch && branch.class === Array);
            default:
                return false;
        }
    });
    if (!isBoundable) {
        s.error((0, _boundJs.writeUnboundableMessage)(s.rootToString()));
    }
    return distributedRange;
};
const hasComparator = (bound, comparator)=>bound.comparator === comparator;
const hasComparatorIn = (bound, comparators)=>bound.comparator in comparators;
const writeInvalidLimitMessage = (comparator, limit)=>`Comparator ${comparator} must be followed by a number literal (was '${limit}')`;
const writeEmptyRangeMessage = (range)=>`${(0, _composeJs.stringifyRange)(range)} is empty`;
