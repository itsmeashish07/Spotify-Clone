"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    parseDefinition: ()=>parseDefinition,
    as: ()=>as,
    writeBadDefinitionTypeMessage: ()=>writeBadDefinitionTypeMessage
});
const _typeJs = require("../scopes/type.js");
const _domainsJs = require("../utils/domains.js");
const _errorsJs = require("../utils/errors.js");
const _objectKindsJs = require("../utils/objectKinds.js");
const _serializeJs = require("../utils/serialize.js");
const _tupleJs = require("./ast/tuple.js");
const _recordJs = require("./record.js");
const _stringJs = require("./string/string.js");
const parseDefinition = (def, ctx)=>{
    const domain = (0, _domainsJs.domainOf)(def);
    if (domain === "string") {
        return (0, _stringJs.parseString)(def, ctx);
    }
    if (domain !== "object") {
        return (0, _errorsJs.throwParseError)(writeBadDefinitionTypeMessage(domain));
    }
    const objectKind = (0, _objectKindsJs.objectKindOf)(def);
    switch(objectKind){
        case "Object":
            return (0, _recordJs.parseRecord)(def, ctx);
        case "Array":
            return (0, _tupleJs.parseTuple)(def, ctx);
        case "RegExp":
            return {
                string: {
                    regex: def.source
                }
            };
        case "Function":
            if ((0, _typeJs.isType)(def)) {
                return ctx.type.scope.addAnonymousTypeReference(def, ctx);
            }
            if (isThunk(def)) {
                const returned = def();
                if ((0, _typeJs.isType)(returned)) {
                    return ctx.type.scope.addAnonymousTypeReference(returned, ctx);
                }
            }
            return (0, _errorsJs.throwParseError)(writeBadDefinitionTypeMessage("Function"));
        default:
            return (0, _errorsJs.throwParseError)(writeBadDefinitionTypeMessage(objectKind ?? (0, _serializeJs.stringify)(def)));
    }
};
const as = Symbol("as");
const isThunk = (def)=>typeof def === "function" && def.length === 0;
const writeBadDefinitionTypeMessage = (actual)=>`Type definitions must be strings or objects (was ${actual})`;
