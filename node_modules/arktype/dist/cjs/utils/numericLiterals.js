"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    wellFormedNumberMatcher: ()=>wellFormedNumberMatcher,
    wellFormedIntegerMatcher: ()=>wellFormedIntegerMatcher,
    isWellFormedInteger: ()=>isWellFormedInteger,
    wellFormedNonNegativeIntegerMatcher: ()=>wellFormedNonNegativeIntegerMatcher,
    writeMalformedNumericLiteralMessage: ()=>writeMalformedNumericLiteralMessage,
    tryParseWellFormedNumber: ()=>tryParseWellFormedNumber,
    tryParseWellFormedInteger: ()=>tryParseWellFormedInteger,
    tryParseWellFormedBigint: ()=>tryParseWellFormedBigint
});
const _errorsJs = require("./errors.js");
const wellFormedNumberMatcher = /^(?!^-0$)-?(?:0|[1-9]\d*)(?:\.\d*[1-9])?$/;
const isWellFormedNumber = (s)=>wellFormedNumberMatcher.test(s);
const numberLikeMatcher = /^-?\d*\.?\d*$/;
const isNumberLike = (s)=>s.length !== 0 && numberLikeMatcher.test(s);
const wellFormedIntegerMatcher = /^(?:0|(?:-?[1-9]\d*))$/;
const isWellFormedInteger = (s)=>wellFormedIntegerMatcher.test(s);
const wellFormedNonNegativeIntegerMatcher = /^(?:0|(?:[1-9]\d*))$/;
const integerLikeMatcher = /^-?\d+$/;
const isIntegerLike = (s)=>integerLikeMatcher.test(s);
const numericLiteralDescriptions = {
    number: "a number",
    bigint: "a bigint",
    integer: "an integer"
};
const writeMalformedNumericLiteralMessage = (def, kind)=>`'${def}' was parsed as ${numericLiteralDescriptions[kind]} but could not be narrowed to a literal value. Avoid unnecessary leading or trailing zeros and other abnormal notation`;
const isWellFormed = (def, kind)=>kind === "number" ? isWellFormedNumber(def) : isWellFormedInteger(def);
const parseKind = (def, kind)=>kind === "number" ? Number(def) : Number.parseInt(def);
const isKindLike = (def, kind)=>kind === "number" ? isNumberLike(def) : isIntegerLike(def);
const tryParseWellFormedNumber = (token, errorOnFail)=>parseWellFormed(token, "number", errorOnFail);
const tryParseWellFormedInteger = (token, errorOnFail)=>parseWellFormed(token, "integer", errorOnFail);
const parseWellFormed = (token, kind, errorOnFail)=>{
    const value = parseKind(token, kind);
    if (!Number.isNaN(value)) {
        if (isWellFormed(token, kind)) {
            return value;
        }
        if (isKindLike(token, kind)) {
            // If the definition looks like the correct numeric kind but is
            // not well-formed, always throw.
            return (0, _errorsJs.throwParseError)(writeMalformedNumericLiteralMessage(token, kind));
        }
    }
    return errorOnFail ? (0, _errorsJs.throwParseError)(errorOnFail === true ? `Failed to parse ${numericLiteralDescriptions[kind]} from '${token}'` : errorOnFail) : undefined;
};
const tryParseWellFormedBigint = (def)=>{
    if (def[def.length - 1] !== "n") {
        return;
    }
    const maybeIntegerLiteral = def.slice(0, -1);
    let value;
    try {
        value = BigInt(maybeIntegerLiteral);
    } catch  {
        return;
    }
    if (wellFormedIntegerMatcher.test(maybeIntegerLiteral)) {
        return value;
    }
    if (integerLikeMatcher.test(maybeIntegerLiteral)) {
        // If the definition looks like a bigint but is
        // not well-formed, throw.
        return (0, _errorsJs.throwParseError)(writeMalformedNumericLiteralMessage(def, "bigint"));
    }
};
