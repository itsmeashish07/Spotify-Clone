"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    comparePredicates: ()=>comparePredicates,
    predicateIntersection: ()=>predicateIntersection,
    predicateUnion: ()=>predicateUnion,
    flattenPredicate: ()=>flattenPredicate,
    isLiteralCondition: ()=>isLiteralCondition
});
const _genericsJs = require("../utils/generics.js");
const _objectKindsJs = require("../utils/objectKinds.js");
const _branchJs = require("./branch.js");
const _composeJs = require("./compose.js");
const _discriminateJs = require("./discriminate.js");
const emptyRulesIfTrue = (predicate)=>predicate === true ? {} : predicate;
const comparePredicates = (l, r, context)=>{
    if (l === true && r === true) {
        return (0, _composeJs.equality)();
    }
    if (!(0, _objectKindsJs.isArray)(l) && !(0, _objectKindsJs.isArray)(r)) {
        const result = (0, _branchJs.branchIntersection)(emptyRulesIfTrue(l), emptyRulesIfTrue(r), context);
        return result === l ? l : result === r ? r : result;
    }
    const lBranches = (0, _genericsJs.listFrom)(emptyRulesIfTrue(l));
    const rBranches = (0, _genericsJs.listFrom)(emptyRulesIfTrue(r));
    const comparison = (0, _branchJs.compareBranches)(lBranches, rBranches, context);
    if (comparison.equalities.length === lBranches.length && comparison.equalities.length === rBranches.length) {
        return (0, _composeJs.equality)();
    }
    if (comparison.lExtendsR.length + comparison.equalities.length === lBranches.length) {
        return l;
    }
    if (comparison.rExtendsL.length + comparison.equalities.length === rBranches.length) {
        return r;
    }
    return comparison;
};
const predicateIntersection = (domain, l, r, state)=>{
    state.domain = domain;
    const comparison = comparePredicates(l, r, state);
    if (!(0, _branchJs.isBranchComparison)(comparison)) {
        return comparison;
    }
    const resultBranches = [
        ...comparison.distinctIntersections,
        ...comparison.equalities.map((indices)=>comparison.lBranches[indices[0]]),
        ...comparison.lExtendsR.map((lIndex)=>comparison.lBranches[lIndex]),
        ...comparison.rExtendsL.map((rIndex)=>comparison.rBranches[rIndex])
    ];
    if (resultBranches.length === 0) {
        state.addDisjoint("union", comparison.lBranches, comparison.rBranches);
    }
    return resultBranches.length === 1 ? resultBranches[0] : resultBranches;
};
const predicateUnion = (domain, l, r, type)=>{
    const state = new _composeJs.IntersectionState(type, "|");
    const comparison = comparePredicates(l, r, state);
    if (!(0, _branchJs.isBranchComparison)(comparison)) {
        return (0, _composeJs.isEquality)(comparison) || comparison === l ? r : comparison === r ? l : // subtype of the other, it consists of two opposite literals
        // and can be simplified to a non-literal boolean.
        domain === "boolean" ? true : [
            emptyRulesIfTrue(l),
            emptyRulesIfTrue(r)
        ];
    }
    const resultBranches = [
        ...comparison.lBranches.filter((_, lIndex)=>!comparison.lExtendsR.includes(lIndex) && !comparison.equalities.some((indexPair)=>indexPair[0] === lIndex)),
        ...comparison.rBranches.filter((_, rIndex)=>!comparison.rExtendsL.includes(rIndex) && !comparison.equalities.some((indexPair)=>indexPair[1] === rIndex))
    ];
    return resultBranches.length === 1 ? resultBranches[0] : resultBranches;
};
const flattenPredicate = (predicate, context)=>{
    if (predicate === true) {
        return [];
    }
    return (0, _objectKindsJs.isArray)(predicate) ? (0, _discriminateJs.flattenBranches)(predicate, context) : (0, _branchJs.flattenBranch)(predicate, context);
};
const isLiteralCondition = (predicate)=>typeof predicate === "object" && "value" in predicate;
