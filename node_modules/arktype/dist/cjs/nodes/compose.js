"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    composeIntersection: ()=>composeIntersection,
    undefinedOperandsMessage: ()=>undefinedOperandsMessage,
    disjointDescriptionWriters: ()=>disjointDescriptionWriters,
    stringifyRange: ()=>stringifyRange,
    IntersectionState: ()=>IntersectionState,
    anonymousDisjoint: ()=>anonymousDisjoint,
    isDisjoint: ()=>isDisjoint,
    equality: ()=>equality,
    isEquality: ()=>isEquality,
    composeKeyedIntersection: ()=>composeKeyedIntersection
});
const _errorsJs = require("../utils/errors.js");
const _genericsJs = require("../utils/generics.js");
const _pathsJs = require("../utils/paths.js");
const _serializeJs = require("../utils/serialize.js");
function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
    return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateFieldInit(obj, privateMap, value) {
    _checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
    _classApplyDescriptorSet(receiver, descriptor, value);
    return value;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const composeIntersection = (reducer)=>(l, r, state)=>l === undefined ? r === undefined ? (0, _errorsJs.throwInternalError)(undefinedOperandsMessage) : r : r === undefined ? l : reducer(l, r, state);
const undefinedOperandsMessage = `Unexpected operation two undefined operands`;
const disjointDescriptionWriters = {
    domain: ({ l , r  })=>`${l.join(", ")} and ${r.join(", ")}`,
    range: ({ l , r  })=>`${stringifyRange(l)} and ${stringifyRange(r)}`,
    class: ({ l , r  })=>`classes ${typeof l === "string" ? l : l.name} and ${typeof r === "string" ? r : r.name}`,
    tupleLength: ({ l , r  })=>`tuples of length ${l} and ${r}`,
    value: ({ l , r  })=>`literal values ${(0, _serializeJs.stringify)(l)} and ${(0, _serializeJs.stringify)(r)}`,
    leftAssignability: ({ l , r  })=>`literal value ${(0, _serializeJs.stringify)(l.value)} and ${(0, _serializeJs.stringify)(r)}`,
    rightAssignability: ({ l , r  })=>`literal value ${(0, _serializeJs.stringify)(r.value)} and ${(0, _serializeJs.stringify)(l)}`,
    union: ({ l , r  })=>`branches ${(0, _serializeJs.stringify)(l)} and branches ${(0, _serializeJs.stringify)(r)}`
};
const stringifyRange = (range)=>"limit" in range ? `the range of exactly ${range.limit}` : range.min ? range.max ? `the range bounded by ${range.min.comparator}${range.min.limit} and ${range.max.comparator}${range.max.limit}` : `${range.min.comparator}${range.min.limit}` : range.max ? `${range.max.comparator}${range.max.limit}` : "the unbounded range";
var _disjoints = /*#__PURE__*/ new WeakMap();
class IntersectionState {
    get disjoints() {
        return _classPrivateFieldGet(this, _disjoints);
    }
    addDisjoint(kind, l, r) {
        _classPrivateFieldGet(this, _disjoints)[`${this.path}`] = {
            kind,
            l,
            r,
            lOptional: this.lOptional,
            rOptional: this.rOptional
        };
        return empty;
    }
    constructor(type, lastOperator){
        _defineProperty(this, "type", void 0);
        _defineProperty(this, "lastOperator", void 0);
        _defineProperty(this, "path", void 0);
        _defineProperty(this, "lOptional", void 0);
        _defineProperty(this, "rOptional", void 0);
        _defineProperty(this, "domain", void 0);
        _classPrivateFieldInit(this, _disjoints, {
            writable: true,
            value: void 0
        });
        this.type = type;
        this.lastOperator = lastOperator;
        this.path = new _pathsJs.Path();
        this.lOptional = false;
        this.rOptional = false;
        _classPrivateFieldSet(this, _disjoints, {});
    }
}
const empty = Symbol("empty");
const anonymousDisjoint = ()=>empty;
const isDisjoint = (result)=>result === empty;
const equal = Symbol("equal");
const equality = ()=>equal;
const isEquality = (result)=>result === equal;
const composeKeyedIntersection = (reducer, config)=>(l, r, state)=>{
        const result = {};
        const keys = (0, _genericsJs.objectKeysOf)({
            ...l,
            ...r
        });
        let lImpliesR = true;
        let rImpliesL = true;
        for (const k of keys){
            const keyResult = typeof reducer === "function" ? reducer(k, l[k], r[k], state) : reducer[k](l[k], r[k], state);
            if (isEquality(keyResult)) {
                if (l[k] !== undefined) {
                    result[k] = l[k];
                }
            } else if (isDisjoint(keyResult)) {
                if (config.onEmpty === "omit") {
                    lImpliesR = false;
                    rImpliesL = false;
                } else {
                    return empty;
                }
            } else {
                if (keyResult !== undefined) {
                    result[k] = keyResult;
                }
                lImpliesR && (lImpliesR = keyResult === l[k]);
                rImpliesL && (rImpliesL = keyResult === r[k]);
            }
        }
        return lImpliesR ? rImpliesL ? equality() : l : rImpliesL ? r : result;
    };
