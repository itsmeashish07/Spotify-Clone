"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    isBranchComparison: ()=>isBranchComparison,
    compareBranches: ()=>compareBranches,
    isTransformationBranch: ()=>isTransformationBranch,
    flattenBranch: ()=>flattenBranch,
    branchIntersection: ()=>branchIntersection
});
const _intersectionJs = require("../parse/ast/intersection.js");
const _domainsJs = require("../utils/domains.js");
const _errorsJs = require("../utils/errors.js");
const _composeJs = require("./compose.js");
const _rulesJs = require("./rules/rules.js");
const isBranchComparison = (comparison)=>comparison?.lBranches !== undefined;
const compareBranches = (lConditions, rConditions, state)=>{
    const result = {
        lBranches: lConditions,
        rBranches: rConditions,
        lExtendsR: [],
        rExtendsL: [],
        equalities: [],
        distinctIntersections: []
    };
    const pairs = rConditions.map((condition)=>({
            condition,
            distinct: []
        }));
    lConditions.forEach((l, lIndex)=>{
        let lImpliesR = false;
        const distinct = pairs.map((rPairs, rIndex)=>{
            if (lImpliesR || !rPairs.distinct) {
                return null;
            }
            const r = rPairs.condition;
            const subresult = branchIntersection(l, r, state);
            if ((0, _composeJs.isDisjoint)(subresult)) {
                // doesn't tell us about any redundancies or add a distinct pair
                return null;
            } else if (subresult === l) {
                result.lExtendsR.push(lIndex);
                // If l is a subtype of the current r branch, intersections
                // with the remaining branches of r won't lead to distinct
                // branches, so we set a flag indicating we can skip them.
                lImpliesR = true;
                return null;
            } else if (subresult === r) {
                result.rExtendsL.push(rIndex);
                // If r is a subtype of the current l branch, it is removed
                // from pairsByR because future intersections won't lead to
                // distinct branches.
                rPairs.distinct = null;
                return null;
            } else if ((0, _composeJs.isEquality)(subresult)) {
                // Combination of l and r subtype cases.
                result.equalities.push([
                    lIndex,
                    rIndex
                ]);
                lImpliesR = true;
                rPairs.distinct = null;
                return null;
            } else if ((0, _domainsJs.hasDomain)(subresult, "object")) {
                // Neither branch is a subtype of the other, return
                // the result of the intersection as a candidate
                // branch for the final union
                return subresult;
            }
            return (0, _errorsJs.throwInternalError)(`Unexpected predicate intersection result of type '${(0, _domainsJs.domainOf)(subresult)}'`);
        });
        if (!lImpliesR) {
            for(let i = 0; i < pairs.length; i++){
                if (distinct[i]) {
                    pairs[i].distinct?.push(distinct[i]);
                }
            }
        }
    });
    result.distinctIntersections = pairs.flatMap((pairs)=>pairs.distinct ?? []);
    return result;
};
const isTransformationBranch = (branch)=>"rules" in branch;
const flattenBranch = (branch, ctx)=>{
    if (isTransformationBranch(branch)) {
        const result = (0, _rulesJs.flattenRules)(branch.rules, ctx);
        if (branch.morph) {
            if (typeof branch.morph === "function") {
                result.push([
                    "morph",
                    branch.morph
                ]);
            } else {
                for (const morph of branch.morph){
                    result.push([
                        "morph",
                        morph
                    ]);
                }
            }
        }
        return result;
    }
    return (0, _rulesJs.flattenRules)(branch, ctx);
};
const rulesOf = (branch)=>branch.rules ?? branch;
const branchIntersection = (l, r, state)=>{
    const lRules = rulesOf(l);
    const rRules = rulesOf(r);
    const rulesResult = (0, _rulesJs.rulesIntersection)(lRules, rRules, state);
    if ("morph" in l) {
        if ("morph" in r) {
            if (l.morph === r.morph) {
                return (0, _composeJs.isEquality)(rulesResult) || (0, _composeJs.isDisjoint)(rulesResult) ? rulesResult : {
                    rules: rulesResult,
                    morph: l.morph
                };
            }
            return state.lastOperator === "&" ? (0, _errorsJs.throwParseError)((0, _intersectionJs.writeImplicitNeverMessage)(state.path, "Intersection", "of morphs")) : {};
        }
        return (0, _composeJs.isDisjoint)(rulesResult) ? rulesResult : {
            rules: (0, _composeJs.isEquality)(rulesResult) ? l.rules : rulesResult,
            morph: l.morph
        };
    }
    if ("morph" in r) {
        return (0, _composeJs.isDisjoint)(rulesResult) ? rulesResult : {
            rules: (0, _composeJs.isEquality)(rulesResult) ? r.rules : rulesResult,
            morph: r.morph
        };
    }
    return rulesResult;
};
