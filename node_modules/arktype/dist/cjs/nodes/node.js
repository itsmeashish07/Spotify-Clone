"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    isConfigNode: ()=>isConfigNode,
    nodeIntersection: ()=>nodeIntersection,
    rootIntersection: ()=>rootIntersection,
    rootUnion: ()=>rootUnion,
    flattenType: ()=>flattenType,
    flattenNode: ()=>flattenNode,
    flattenTypeNode: ()=>flattenTypeNode,
    isLiteralNode: ()=>isLiteralNode,
    resolutionExtendsDomain: ()=>resolutionExtendsDomain,
    toArrayNode: ()=>toArrayNode
});
const _intersectionJs = require("../parse/ast/intersection.js");
const _errorsJs = require("../utils/errors.js");
const _genericsJs = require("../utils/generics.js");
const _pathsJs = require("../utils/paths.js");
const _composeJs = require("./compose.js");
const _predicateJs = require("./predicate.js");
const _propsJs = require("./rules/props.js");
const isConfigNode = (node)=>"config" in node;
const nodeIntersection = (l, r, state)=>{
    state.domain = undefined;
    const lDomains = state.type.scope.resolveTypeNode(l);
    const rDomains = state.type.scope.resolveTypeNode(r);
    const result = typeNodeIntersection(lDomains, rDomains, state);
    if (typeof result === "object" && !(0, _genericsJs.hasKeys)(result)) {
        return (0, _genericsJs.hasKeys)(state.disjoints) ? (0, _composeJs.anonymousDisjoint)() : state.addDisjoint("domain", (0, _genericsJs.objectKeysOf)(lDomains), (0, _genericsJs.objectKeysOf)(rDomains));
    }
    return result === lDomains ? l : result === rDomains ? r : result;
};
const typeNodeIntersection = (0, _composeJs.composeKeyedIntersection)((domain, l, r, context)=>{
    if (l === undefined) {
        return r === undefined ? (0, _errorsJs.throwInternalError)(_composeJs.undefinedOperandsMessage) : undefined;
    }
    if (r === undefined) {
        return undefined;
    }
    return (0, _predicateJs.predicateIntersection)(domain, l, r, context);
}, {
    onEmpty: "omit"
});
const rootIntersection = (l, r, type)=>{
    const state = new _composeJs.IntersectionState(type, "&");
    const result = nodeIntersection(l, r, state);
    return (0, _composeJs.isDisjoint)(result) ? (0, _errorsJs.throwParseError)((0, _intersectionJs.compileDisjointReasonsMessage)(state.disjoints)) : (0, _composeJs.isEquality)(result) ? l : result;
};
const rootUnion = (l, r, type)=>{
    const lDomains = type.scope.resolveTypeNode(l);
    const rDomains = type.scope.resolveTypeNode(r);
    const result = {};
    const domains = (0, _genericsJs.objectKeysOf)({
        ...lDomains,
        ...rDomains
    });
    for (const domain of domains){
        result[domain] = (0, _genericsJs.hasKey)(lDomains, domain) ? (0, _genericsJs.hasKey)(rDomains, domain) ? (0, _predicateJs.predicateUnion)(domain, lDomains[domain], rDomains[domain], type) : lDomains[domain] : (0, _genericsJs.hasKey)(rDomains, domain) ? rDomains[domain] : (0, _errorsJs.throwInternalError)(_composeJs.undefinedOperandsMessage);
    }
    return result;
};
const hasImpliedDomain = (flatPredicate)=>flatPredicate[0] && (flatPredicate[0][0] === "value" || flatPredicate[0][0] === "class");
const flattenType = (type)=>{
    const ctx = {
        type,
        path: new _pathsJs.Path(),
        lastDomain: "undefined"
    };
    return flattenNode(type.node, ctx);
};
const flattenNode = (node, ctx)=>{
    if (typeof node === "string") {
        return ctx.type.scope.resolve(node).flat;
    }
    const hasConfig = isConfigNode(node);
    const flattenedTypeNode = flattenTypeNode(hasConfig ? node.node : node, ctx);
    return hasConfig ? [
        [
            "config",
            {
                config: (0, _genericsJs.entriesOf)(node.config),
                node: flattenedTypeNode
            }
        ]
    ] : flattenedTypeNode;
};
const flattenTypeNode = (node, ctx)=>{
    const domains = (0, _genericsJs.objectKeysOf)(node);
    if (domains.length === 1) {
        const domain = domains[0];
        const predicate = node[domain];
        if (predicate === true) {
            return domain;
        }
        ctx.lastDomain = domain;
        const flatPredicate = (0, _predicateJs.flattenPredicate)(predicate, ctx);
        return hasImpliedDomain(flatPredicate) ? flatPredicate : [
            [
                "domain",
                domain
            ],
            ...flatPredicate
        ];
    }
    const result = {};
    for (const domain of domains){
        ctx.lastDomain = domain;
        result[domain] = (0, _predicateJs.flattenPredicate)(node[domain], ctx);
    }
    return [
        [
            "domains",
            result
        ]
    ];
};
const isLiteralNode = (node, domain)=>{
    return resolutionExtendsDomain(node, domain) && (0, _predicateJs.isLiteralCondition)(node[domain]);
};
const resolutionExtendsDomain = (resolution, domain)=>{
    const domains = (0, _genericsJs.objectKeysOf)(resolution);
    return domains.length === 1 && domains[0] === domain;
};
const toArrayNode = (node)=>({
        object: {
            class: Array,
            props: {
                [_propsJs.mappedKeys.index]: node
            }
        }
    });
