"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    minComparators: ()=>minComparators,
    maxComparators: ()=>maxComparators,
    isEqualityRange: ()=>isEqualityRange,
    rangeIntersection: ()=>rangeIntersection,
    flattenRange: ()=>flattenRange,
    checkBound: ()=>checkBound,
    compareStrictness: ()=>compareStrictness
});
const _dataJs = require("../../utils/data.js");
const _composeJs = require("../compose.js");
const minComparators = {
    ">": true,
    ">=": true
};
const maxComparators = {
    "<": true,
    "<=": true
};
const isEqualityRange = (range)=>"comparator" in range;
const rangeIntersection = (0, _composeJs.composeIntersection)((l, r, state)=>{
    if (isEqualityRange(l)) {
        if (isEqualityRange(r)) {
            return l.limit === r.limit ? (0, _composeJs.equality)() : state.addDisjoint("range", l, r);
        }
        return rangeAllows(r, l.limit) ? l : state.addDisjoint("range", l, r);
    }
    if (isEqualityRange(r)) {
        return rangeAllows(l, r.limit) ? r : state.addDisjoint("range", l, r);
    }
    const stricterMin = compareStrictness("min", l.min, r.min);
    const stricterMax = compareStrictness("max", l.max, r.max);
    if (stricterMin === "l") {
        if (stricterMax === "r") {
            return compareStrictness("min", l.min, r.max) === "l" ? state.addDisjoint("range", l, r) : {
                min: l.min,
                max: r.max
            };
        }
        return l;
    }
    if (stricterMin === "r") {
        if (stricterMax === "l") {
            return compareStrictness("max", l.max, r.min) === "l" ? state.addDisjoint("range", l, r) : {
                min: r.min,
                max: l.max
            };
        }
        return r;
    }
    return stricterMax === "l" ? l : stricterMax === "r" ? r : (0, _composeJs.equality)();
});
const rangeAllows = (range, n)=>isEqualityRange(range) ? n === range.limit : minAllows(range.min, n) && maxAllows(range.max, n);
const minAllows = (min, n)=>!min || n > min.limit || n === min.limit && !isExclusive(min.comparator);
const maxAllows = (max, n)=>!max || n < max.limit || n === max.limit && !isExclusive(max.comparator);
const flattenRange = (entries, range, ctx)=>{
    const units = ctx.lastDomain === "string" ? "characters" : ctx.lastDomain === "object" ? "items long" : undefined;
    if (isEqualityRange(range)) {
        return entries.push([
            "bound",
            units ? {
                ...range,
                units
            } : range
        ]);
    }
    if (range.min) {
        entries.push([
            "bound",
            units ? {
                ...range.min,
                units
            } : range.min
        ]);
    }
    if (range.max) {
        entries.push([
            "bound",
            units ? {
                ...range.max,
                units
            } : range.max
        ]);
    }
};
const checkBound = (bound, state)=>comparatorCheckers[bound.comparator]((0, _dataJs.sizeOf)(state.data), bound.limit) || !state.problems.add("bound", bound);
const comparatorCheckers = {
    "<": (size, limit)=>size < limit,
    ">": (size, limit)=>size > limit,
    "<=": (size, limit)=>size <= limit,
    ">=": (size, limit)=>size >= limit,
    "==": (size, limit)=>size === limit
};
const compareStrictness = (kind, l, r)=>!l ? !r ? "=" : "r" : !r ? "l" : l.limit === r.limit ? isExclusive(l.comparator) ? isExclusive(r.comparator) ? "=" : "l" : isExclusive(r.comparator) ? "r" : "=" : kind === "min" ? l.limit > r.limit ? "l" : "r" : l.limit < r.limit ? "l" : "r";
const isExclusive = (comparator)=>comparator.length === 1;
