"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    isOptional: ()=>isOptional,
    isPrerequisite: ()=>isPrerequisite,
    mappedKeys: ()=>mappedKeys,
    propToNode: ()=>propToNode,
    propsIntersection: ()=>propsIntersection,
    flattenProps: ()=>flattenProps
});
const _composeJs = require("../compose.js");
const _nodeJs = require("../node.js");
const isOptional = (prop)=>prop[0] === "?";
const isPrerequisite = (prop)=>prop[0] === "!";
const mappedKeys = {
    index: "[index]"
};
const propToNode = (prop)=>isOptional(prop) || isPrerequisite(prop) ? prop[1] : prop;
const getTupleLengthIfPresent = (result)=>{
    if (typeof result.length === "object" && isPrerequisite(result.length) && typeof result.length[1] !== "string" && (0, _nodeJs.isLiteralNode)(result.length[1], "number")) {
        return result.length[1].number.value;
    }
};
const propsIntersection = (0, _composeJs.composeIntersection)((l, r, state)=>{
    const result = propKeysIntersection(l, r, state);
    if (typeof result === "symbol") {
        return result;
    }
    const lengthValue = getTupleLengthIfPresent(result);
    if (lengthValue === undefined || !(mappedKeys.index in result)) {
        return result;
    }
    // if we are at this point, we have an array with an exact length (i.e.
    // a tuple) and an index signature. Intersection each tuple item with
    // the index signature node and remove the index signature via a new
    // updated result, copied from result to avoid mutating existing references.
    const { [mappedKeys.index]: indexProp , ...updatedResult } = result;
    const indexNode = propToNode(indexProp);
    for(let i = 0; i < lengthValue; i++){
        if (!updatedResult[i]) {
            updatedResult[i] = indexNode;
            continue;
        }
        const existingNodeAtIndex = propToNode(updatedResult[i]);
        state.path.push(`${i}`);
        const updatedResultAtIndex = (0, _nodeJs.nodeIntersection)(existingNodeAtIndex, indexNode, state);
        state.path.pop();
        if ((0, _composeJs.isDisjoint)(updatedResultAtIndex)) {
            return updatedResultAtIndex;
        } else if (!(0, _composeJs.isEquality)(updatedResultAtIndex) && updatedResultAtIndex !== existingNodeAtIndex) {
            updatedResult[i] = updatedResultAtIndex;
        }
    }
    return updatedResult;
});
const propKeysIntersection = (0, _composeJs.composeKeyedIntersection)((propKey, l, r, context)=>{
    if (l === undefined) {
        return r === undefined ? (0, _composeJs.equality)() : r;
    }
    if (r === undefined) {
        return l;
    }
    context.path.push(propKey);
    const previousLOptional = context.lOptional;
    const previousROptional = context.rOptional;
    (_context = context).lOptional || (_context.lOptional = isOptional(l));
    (_context1 = context).rOptional || (_context1.rOptional = isOptional(r));
    const result = (0, _nodeJs.nodeIntersection)(propToNode(l), propToNode(r), context);
    const resultIsOptional = context.lOptional && context.rOptional;
    context.rOptional = previousROptional;
    context.lOptional = previousLOptional;
    context.path.pop();
    if ((0, _composeJs.isDisjoint)(result) && resultIsOptional) {
        var _context, _context1;
        // If an optional key has an empty intersection, the type can
        // still be satisfied as long as the key is not included. Set
        // the node to never rather than invalidating the type.
        return {};
    }
    return result;
}, {
    onEmpty: "bubble"
});
const flattenProps = (entries, props, ctx)=>{
    const keyConfig = ctx.type.config?.keys ?? ctx.type.scope.config.keys;
    return keyConfig === "loose" ? flattenLooseProps(entries, props, ctx) : flattenPropsRecord(keyConfig, entries, props, ctx);
};
const flattenLooseProps = (entries, props, ctx)=>{
    // if we don't care about extraneous keys, flatten props so we can iterate over the definitions directly
    for(const k in props){
        const prop = props[k];
        ctx.path.push(k);
        if (k === mappedKeys.index) {
            entries.push([
                "indexProp",
                (0, _nodeJs.flattenNode)(propToNode(prop), ctx)
            ]);
        } else if (isOptional(prop)) {
            entries.push([
                "optionalProp",
                [
                    k,
                    (0, _nodeJs.flattenNode)(prop[1], ctx)
                ]
            ]);
        } else if (isPrerequisite(prop)) {
            entries.push([
                "prerequisiteProp",
                [
                    k,
                    (0, _nodeJs.flattenNode)(prop[1], ctx)
                ]
            ]);
        } else {
            entries.push([
                "requiredProp",
                [
                    k,
                    (0, _nodeJs.flattenNode)(prop, ctx)
                ]
            ]);
        }
        ctx.path.pop();
    }
};
const flattenPropsRecord = (kind, entries, props, ctx)=>{
    const result = {
        required: {},
        optional: {}
    };
    // if we need to keep track of extraneous keys, either to add problems or
    // remove them, store the props as a Record to optimize for presence
    // checking as we iterate over the data
    for(const k in props){
        const prop = props[k];
        ctx.path.push(k);
        if (k === mappedKeys.index) {
            result.index = (0, _nodeJs.flattenNode)(propToNode(prop), ctx);
        } else if (isOptional(prop)) {
            result.optional[k] = (0, _nodeJs.flattenNode)(prop[1], ctx);
        } else if (isPrerequisite(prop)) {
            // we still have to push prerequisite props as normal entries so they can be checked first
            entries.push([
                "prerequisiteProp",
                [
                    k,
                    (0, _nodeJs.flattenNode)(prop[1], ctx)
                ]
            ]);
        } else {
            result.required[k] = (0, _nodeJs.flattenNode)(prop, ctx);
        }
        ctx.path.pop();
    }
    entries.push([
        `${kind}Props`,
        result
    ]);
};
