"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    initializeType: ()=>initializeType,
    isType: ()=>isType,
    isAnonymousName: ()=>isAnonymousName
});
const _traverseJs = require("../traverse/traverse.js");
const _chainableNoOpProxyJs = require("../utils/chainableNoOpProxy.js");
const initializeType = (name, definition, config, scope)=>{
    const root = {
        // temporarily initialize node/flat to aliases that will be included in
        // the final type in case of cyclic resolutions
        node: name,
        flat: [
            [
                "alias",
                name
            ]
        ],
        allows: (data)=>!namedTraverse(data).problems,
        assert: (data)=>{
            const result = namedTraverse(data);
            return result.problems ? result.problems.throw() : result.data;
        },
        infer: _chainableNoOpProxyJs.chainableNoOpProxy,
        inferIn: _chainableNoOpProxyJs.chainableNoOpProxy,
        qualifiedName: isAnonymousName(name) ? scope.getAnonymousQualifiedName(name) : `${scope.name}.${name}`,
        definition,
        scope,
        includesMorph: false,
        config
    };
    // define within a key to dynamically assign a name to the function
    const namedTraverse = {
        [name]: (data)=>(0, _traverseJs.traverseRoot)(namedTraverse, data)
    }[name];
    const t = Object.assign(namedTraverse, root);
    return t;
};
const isType = (value)=>value?.infer === _chainableNoOpProxyJs.chainableNoOpProxy;
const isAnonymousName = (name)=>name[0] === "Î»";
