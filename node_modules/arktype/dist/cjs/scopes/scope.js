"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    compileScopeOptions: ()=>compileScopeOptions,
    isConfigTuple: ()=>isConfigTuple,
    Scope: ()=>Scope,
    scope: ()=>scope,
    rootScope: ()=>rootScope,
    rootType: ()=>rootType,
    writeShallowCycleErrorMessage: ()=>writeShallowCycleErrorMessage,
    writeDuplicateAliasesMessage: ()=>writeDuplicateAliasesMessage
});
const _nodeJs = require("../nodes/node.js");
const _definitionJs = require("../parse/definition.js");
const _problemsJs = require("../traverse/problems.js");
const _chainableNoOpProxyJs = require("../utils/chainableNoOpProxy.js");
const _errorsJs = require("../utils/errors.js");
const _genericsJs = require("../utils/generics.js");
const _pathsJs = require("../utils/paths.js");
const _cacheJs = require("./cache.js");
const _typeJs = require("./type.js");
function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
    return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateFieldInit(obj, privateMap, value) {
    _checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
    _classApplyDescriptorSet(receiver, descriptor, value);
    return value;
}
function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
}
function _classPrivateMethodInit(obj, privateSet) {
    _checkPrivateRedeclaration(obj, privateSet);
    privateSet.add(obj);
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const compileScopeOptions = (opts)=>({
        codes: (0, _problemsJs.compileProblemWriters)(opts.codes),
        keys: opts.keys ?? "loose"
    });
let anonymousScopeCount = 0;
const scopeRegistry = {};
const spaceRegistry = {};
const isConfigTuple = (def)=>Array.isArray(def) && def[1] === ":";
var _resolutions = /*#__PURE__*/ new WeakMap(), _exports = /*#__PURE__*/ new WeakMap(), _register = /*#__PURE__*/ new WeakSet(), _cacheSpaces = /*#__PURE__*/ new WeakSet(), _initializeContext = /*#__PURE__*/ new WeakSet(), _resolveRecurse = /*#__PURE__*/ new WeakSet();
class Scope {
    getAnonymousQualifiedName(base) {
        let increment = 0;
        let id = base;
        while(this.isResolvable(id)){
            id = `${base}${increment++}`;
        }
        return `${this.name}.${id}`;
    }
    addAnonymousTypeReference(referencedType, ctx) {
        var _ctx_type;
        (_ctx_type = ctx.type).includesMorph || (_ctx_type.includesMorph = referencedType.includesMorph);
        return referencedType.node;
    }
    get infer() {
        return _chainableNoOpProxyJs.chainableNoOpProxy;
    }
    compile() {
        if (!spaceRegistry[this.name]) {
            for(const name in this.aliases){
                this.resolve(name);
            }
            spaceRegistry[this.name] = _classPrivateFieldGet(this, _exports).root;
        }
        return _classPrivateFieldGet(this, _exports).root;
    }
    addParsedReferenceIfResolvable(name, ctx) {
        var _ctx_type;
        const resolution = _classPrivateMethodGet(this, _resolveRecurse, resolveRecurse).call(this, name, "undefined", [
            name
        ]);
        if (!resolution) {
            return false;
        }
        (_ctx_type = ctx.type).includesMorph || (_ctx_type.includesMorph = resolution.includesMorph);
        return true;
    }
    resolve(name) {
        return _classPrivateMethodGet(this, _resolveRecurse, resolveRecurse).call(this, name, "throw", [
            name
        ]);
    }
    resolveNode(node) {
        return typeof node === "string" ? this.resolveNode(this.resolve(node).node) : node;
    }
    resolveTypeNode(node) {
        const resolution = this.resolveNode(node);
        return (0, _nodeJs.isConfigNode)(resolution) ? resolution.node : resolution;
    }
    isResolvable(name) {
        return _classPrivateFieldGet(this, _resolutions).has(name) || this.aliases[name];
    }
    constructor(aliases, opts = {}){
        _classPrivateMethodInit(this, _register);
        _classPrivateMethodInit(this, _cacheSpaces);
        _classPrivateMethodInit(this, _initializeContext);
        _classPrivateMethodInit(this, _resolveRecurse);
        _defineProperty(this, "aliases", void 0);
        _defineProperty(this, "name", void 0);
        _defineProperty(this, "config", void 0);
        _defineProperty(this, "parseCache", void 0);
        _classPrivateFieldInit(this, _resolutions, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldInit(this, _exports, {
            writable: true,
            value: void 0
        });
        _defineProperty(this, "expressions", void 0);
        _defineProperty(this, "intersection", void 0);
        _defineProperty(this, "union", void 0);
        _defineProperty(this, "arrayOf", void 0);
        _defineProperty(this, "keyOf", void 0);
        _defineProperty(this, "valueOf", void 0);
        _defineProperty(this, "instanceOf", void 0);
        _defineProperty(this, "narrow", void 0);
        _defineProperty(this, "morph", void 0);
        _defineProperty(this, "type", void 0);
        this.aliases = aliases;
        this.parseCache = new _cacheJs.Cache();
        _classPrivateFieldSet(this, _resolutions, new _cacheJs.Cache());
        _classPrivateFieldSet(this, _exports, new _cacheJs.Cache());
        this.expressions = {
            intersection: (l, r, opts)=>this.type([
                    l,
                    "&",
                    r
                ], opts),
            union: (l, r, opts)=>this.type([
                    l,
                    "|",
                    r
                ], opts),
            arrayOf: (def, opts)=>this.type([
                    def,
                    "[]"
                ], opts),
            keyOf: (def, opts)=>this.type([
                    "keyof",
                    def
                ], opts),
            node: (def, opts)=>this.type([
                    "node",
                    def
                ], opts),
            instanceOf: (def, opts)=>this.type([
                    "instanceof",
                    def
                ], opts),
            valueOf: (def, opts)=>this.type([
                    "===",
                    def
                ], opts),
            narrow: (def, fn, opts)=>this.type([
                    def,
                    "=>",
                    fn
                ], opts),
            morph: (def, fn, opts)=>this.type([
                    def,
                    "|>",
                    fn
                ], opts)
        };
        this.intersection = this.expressions.intersection;
        this.union = this.expressions.union;
        this.arrayOf = this.expressions.arrayOf;
        this.keyOf = this.expressions.keyOf;
        this.valueOf = this.expressions.valueOf;
        this.instanceOf = this.expressions.instanceOf;
        this.narrow = this.expressions.narrow;
        this.morph = this.expressions.morph;
        this.type = Object.assign((def, config = {})=>{
            const t = (0, _typeJs.initializeType)("Î»type", def, config, this);
            const ctx = _classPrivateMethodGet(this, _initializeContext, initializeContext).call(this, t);
            const root = (0, _definitionJs.parseDefinition)(def, ctx);
            t.node = (0, _genericsJs.hasKeys)(config) ? {
                config,
                node: this.resolveTypeNode(root)
            } : root;
            t.flat = (0, _nodeJs.flattenType)(t);
            return t;
        }, {
            from: this.expressions.node
        });
        this.name = _classPrivateMethodGet(this, _register, register).call(this, opts);
        if (opts.standard !== false) {
            _classPrivateMethodGet(this, _cacheSpaces, cacheSpaces).call(this, [
                spaceRegistry["standard"]
            ], "imports");
        }
        if (opts.imports) {
            _classPrivateMethodGet(this, _cacheSpaces, cacheSpaces).call(this, opts.imports, "imports");
        }
        if (opts.includes) {
            _classPrivateMethodGet(this, _cacheSpaces, cacheSpaces).call(this, opts.includes, "includes");
        }
        this.config = compileScopeOptions(opts);
    }
}
function register(opts) {
    const name = opts.name ? scopeRegistry[opts.name] ? (0, _errorsJs.throwParseError)(`A scope named '${opts.name}' already exists`) : opts.name : `scope${++anonymousScopeCount}`;
    scopeRegistry[name] = this;
    return name;
}
function cacheSpaces(spaces, kind) {
    for (const space of spaces){
        for(const name in space){
            if (_classPrivateFieldGet(this, _resolutions).has(name) || name in this.aliases) {
                (0, _errorsJs.throwParseError)(writeDuplicateAliasesMessage(name));
            }
            _classPrivateFieldGet(this, _resolutions).set(name, space[name]);
            if (kind === "includes") {
                _classPrivateFieldGet(this, _exports).set(name, space[name]);
            }
        }
    }
}
function initializeContext(type) {
    return {
        type,
        path: new _pathsJs.Path()
    };
}
function resolveRecurse(name, onUnresolvable, seen) {
    const maybeCacheResult = _classPrivateFieldGet(this, _resolutions).get(name);
    if (maybeCacheResult) {
        return maybeCacheResult;
    }
    const aliasDef = this.aliases[name];
    if (!aliasDef) {
        return onUnresolvable === "throw" ? (0, _errorsJs.throwInternalError)(`Unexpectedly failed to resolve alias '${name}'`) : undefined;
    }
    const t = (0, _typeJs.initializeType)(name, aliasDef, {}, this);
    const ctx = _classPrivateMethodGet(this, _initializeContext, initializeContext).call(this, t);
    _classPrivateFieldGet(this, _resolutions).set(name, t);
    _classPrivateFieldGet(this, _exports).set(name, t);
    let node = (0, _definitionJs.parseDefinition)(aliasDef, ctx);
    if (typeof node === "string") {
        if (seen.includes(node)) {
            return (0, _errorsJs.throwParseError)(writeShallowCycleErrorMessage(name, seen));
        }
        seen.push(node);
        node = _classPrivateMethodGet(this, _resolveRecurse, resolveRecurse).call(this, node, "throw", seen).node;
    }
    t.node = node;
    t.flat = (0, _nodeJs.flattenType)(t);
    return t;
}
const scope = (aliases, opts = {})=>new Scope(aliases, opts);
const rootScope = scope({}, {
    name: "root",
    standard: false
});
const rootType = rootScope.type;
const writeShallowCycleErrorMessage = (name, seen)=>`Alias '${name}' has a shallow resolution cycle: ${[
        ...seen,
        name
    ].join("=>")}`;
const writeDuplicateAliasesMessage = (name)=>`Alias '${name}' is already defined`;
